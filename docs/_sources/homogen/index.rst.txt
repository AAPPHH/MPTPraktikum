Homogene Koordinaten
====================

Homogene Koordinaten erlauben es Verschiebungen (Translation), Rotationen (Drehungen) sowie Skalierungen (Größenänderung)
einheitlich über Matrixmultiplikationen abzubilden. Die Verkettung mehrerer
solcher Operationen läßt sich dann mit Hilfe des Assoziativgesetzes zu einer einzigen
Matrix zusammenfassen. Die perspektivische Projektion von 3D Koordinaten auf eine 
zwei-dimensionale Ebene (Pinhole Kamera) läßt sich ebenfalls durch eine entsprechende Matrixmultiplikation
ausdrücken. Damit lässt sich die gesame Abbildung von Objektlokalen 3D Koordinaten in Sensorlokale 2D Koordinaten
direkt über eine einzige Matrix-Multiplikation ausdrücken. In diesem Praktikum 
betrachten wir diese Abbildungsmöglichkeiten.

.. image:: ./screenshot.jpg
   :alt: 3D Abbildungen
   :width: 1024px
   :align: center
    
Einmal von euklidisch nach homogen und zurück
---------------------------------------------

Eine Darstellung :math:`\mathcal{p}` heißt *homogen*, wenn für alle :math:`\lambda\neq 0`
gilt :

.. math::
    \mathcal{p} = \lambda \mathcal{p}

beschreibt das selbe Objekt. Für einen Punkt in euklischen Koordinaten

.. math::
    \textbf{p} = (x_p, y_p, z_p)

schreiben wir in homogenen Koordinaten

.. math::
    \mathcal{p} = (x_p, y_p, z_p, 1)

d.h. wir fügen eine Konstante 1 in der letzten Komponente an. Diese letzte Komponente
nennen wir einheitlich :math:`w`.

Um eine homogene Koordinate :math:`\mathcal{q}=(x_q, y_q, z_q, w_q)` wieder in euklische Koordinaten 
zu überführen dividieren wir durch die :math:`w`-Komponente und erhalten 

.. math::
    \textbf{q} = (x_q / w_q, y_q / w_q, z_q / w_q)

Translationen in homogenen Koordinaten
--------------------------------------

Um einen Punkt :math:`\textbf{p}` in homogenen Koordinaten um einen Vektor 
:math:`\vec v` zu verschieben multiplizieren wir mit der folgenden Matrix

.. math::
    \begin{pmatrix}
        1 & 0 & 0 & x_v\\
        0 & 1 & 0 & y_v\\
        0 & 0 & 1 & z_v\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}\cdot 
    \begin{pmatrix}
    x_p\\y_p\\z_p\\1    
    \end{pmatrix}
    =
    \begin{pmatrix}
    x_p + x_v\\y_p + y_v\\z_p + z_v\\1    
    \end{pmatrix}

Skalierung in homogenen Koordinaten
-----------------------------------

Um einen Punkt :math:`\textbf{p}` in homogenen Koordinaten entlang der 
Hauptachsen zu skalieren (relativ zum Urspung :math:`(0,0,0)`) multiplizieren wir mit der folgenden Matrix

.. math::
    \begin{pmatrix}
        x_s & 0 & 0 & 0\\
        0 & y_s & 0 & 0\\
        0 & 0 & z_s & 0\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}\cdot 
    \begin{pmatrix}
    x_p\\y_p\\z_p\\1    
    \end{pmatrix}
    =
    \begin{pmatrix}
    x_s \cdot x_p\\y_s \cdot y_p\\z_s \cdot z_p\\1    
    \end{pmatrix}

Mehrere Transformationen zusammenfassen
---------------------------------------

Um mehrere Transformationen nacheinander auszuführen multiplizieren
wir die entsprechenden Transformationsmatrizen jeweils **von links**. 
Dabei spielt die Reihenfolge eine Rolle (Matrix-Multiplikation ist nicht kommutativ),
die jeweils weiter rechts stehende Matrix wird dabei zuerst ausgeführt.

**Beispiel**: Zuerst verschieben, dann skalieren

Wollen wir den Punkt :math:`(1,2,3)` zuerst um den Vektor :math:`(-2, -2, -2)` verschieben und dann um den Faktor 4 gleichmässig skalieren, multiplizieren wir mit den 
folgenden Matrizen

.. math::
    \begin{pmatrix}
        4 & 0 & 0 & 0\\
        0 & 4 & 0 & 0\\
        0 & 0 & 4 & 0\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        1 & 0 & 0 & -2\\
        0 & 1 & 0 & -2\\
        0 & 0 & 1 & -2\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        1\\2\\3\\1
    \end{pmatrix}

Multiplizieren wir **manuell** von rechts nach links finden wir zunächst den verschobenen Punkt

.. math::
    \begin{pmatrix}
        1 & 0 & 0 & -2\\
        0 & 1 & 0 & -2\\
        0 & 0 & 1 & -2\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        1\\2\\3\\1
    \end{pmatrix}
    =
    \begin{pmatrix}
        -1\\0\\1\\1
    \end{pmatrix}

Nach Skalierung finden wir dann mit    

.. math::
    \begin{pmatrix}
        4 & 0 & 0 & 0\\
        0 & 4 & 0 & 0\\
        0 & 0 & 4 & 0\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        -1\\0\\1\\1
    \end{pmatrix}
    =
    \begin{pmatrix}
        -4\\0\\4\\1
    \end{pmatrix}

den finalen Punkt. Alternativ können wir mit dem Assoziativgesetz auch die 
beiden Matrix zuerst multiplizieren und finden    

.. math::
    \begin{pmatrix}
        4 & 0 & 0 & 0\\
        0 & 4 & 0 & 0\\
        0 & 0 & 4 & 0\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        1 & 0 & 0 & -2\\
        0 & 1 & 0 & -2\\
        0 & 0 & 1 & -2\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}
    =
    \begin{pmatrix}
        4 & 0 & 0 & -8\\
        0 & 4 & 0 & -8\\
        0 & 0 & 4 & -8\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}

Diese Matrix kodiert die Kombination aus beiden Transformationen in der richtigen Reihenfolge. 

**Beispiel**: Zuerst skalieren, dann verschieben

Vertauschen wir die Reihenfolge 
indem wir den Punkt :math:`(1,2,3)` zuerst um den Faktor 4 gleichmäßig skalieren und dann 
um den Vektor :math:`(-2, -2, -2)` verschieben, vertauschen wir die Matrizen

.. math::
    \begin{pmatrix}
        1 & 0 & 0 & -2\\
        0 & 1 & 0 & -2\\
        0 & 0 & 1 & -2\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        4 & 0 & 0 & 0\\
        0 & 4 & 0 & 0\\
        0 & 0 & 4 & 0\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        1\\2\\3\\1
    \end{pmatrix}

Multiplizieren wir wieder die Matrizen zuerst, finden wir eine andere Abbildungsmatrix

.. math::
    \begin{pmatrix}
        1 & 0 & 0 & -2\\
        0 & 1 & 0 & -2\\
        0 & 0 & 1 & -2\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        4 & 0 & 0 & 0\\
        0 & 4 & 0 & 0\\
        0 & 0 & 4 & 0\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}
    = 
    \begin{pmatrix}
        4 & 0 & 0 & -2\\
        0 & 4 & 0 & -2\\
        0 & 0 & 4 & -2\\
        0 & 0 & 0 & 1\\
    \end{pmatrix}

Rotationen
----------

Um einen Punkt um den Ursprung um die X-Achse zu rotieren verwenden wir die folgende Rotationsmatrix:

.. math::
    R_x(\alpha) = 
    \begin{pmatrix}
    1 & 0 & 0 & 0\\
    0 & \cos(\alpha) & -\sin(\alpha) & 0\\
    0 & \sin(\alpha) &  \cos(\alpha) & 0\\
    0 & 0 & 0 & 1
    \end{pmatrix}

Für eine Rotation um die Y-Achse verwenden wir die folgende Matrix

.. math::
    R_y(\alpha) = 
    \begin{pmatrix}
    \cos(\alpha) & 0 & \sin(\alpha) & 0\\
    0 & 1 & 0 & 0\\
    -\sin(\alpha) & 0 &  \cos(\alpha) & 0\\
    0 & 0 & 0 & 1
    \end{pmatrix}

Für eine Rotation um die Z-Achse verwenden wir die folgende Matrix

.. math::
    R_z(\alpha) = 
    \begin{pmatrix}
    \cos(\alpha) & -\sin(\alpha) & 0 & 0\\
    \sin(\alpha) & \cos(\alpha) & 0 & 0\\
    0 & 0 & 1 & 0\\
    0 & 0 & 0 & 1
    \end{pmatrix}    

Unsere eigene kleine 3D Rendering Engine
----------------------------------------

In diesem Praktikum wollen wir eine einfache kleine 3D Rendering Engine
implementieren welche Punkte im 3D über eine Kamera in 2D-Koordinaten überführt und zeichnet.
Dazu orientieren wir uns stark an dem von `OpenGL <https://learnopengl.com/Getting-started/Coordinate-Systems>`_ 
verwendeten Ansatz und betrachten im folgenden fünf verschiedene Koordinatensystem.

.. image:: ./coordinate_systems.png
    :alt: Koordinatensysteme
    :width: 800px
    :align: center

- Lokale Koordinaten sind die Koordinaten des Objekts relativ zu seinem lokalen Ursprung; das sind die Koordinaten, in denen sich das Objekt anfangs befindet.
- Der nächste Schritt besteht darin, die lokalen Koordinaten in Weltkoordinaten zu transformieren, also Koordinaten im Bezug auf eine globale Welt. Diese Koordinaten sind relativ zu einem globalen Ursprung der Welt, zusammen mit vielen anderen Objekten, die ebenfalls relativ zu diesem Weltursprung platziert sind.
- Als Nächstes transformieren wir die Weltkoordinaten in Ansichtskoordinaten (View-Space-Koordinaten), sodass jede Koordinate aus der Sicht der Kamera oder des Betrachters dargestellt wird.
- Nachdem sich die Koordinaten im View-Space befinden, möchten wir sie in NDC-Koordinaten projizieren. NDC-Koordinaten werden auf den Bereich von -1,0 bis 1,0 normiert und bestimmen, welche Scheitelpunkte (Vertices) letztlich auf dem Bildschirm erscheinen.
- Schließlich transformieren wir die NDC-Koordinaten in Bildschirmkoordinaten. Dabei werden die Koordinaten von -1,0 bis 1,0 in Pixelkoordiaten im Zielbild überführt.

Lokale und Weltkoordinaten
--------------------------
Die :code-block:`local_to_world` Transformation beschreibt wie sich die 
lokalen Koordinaten eines Objektes in Weltkoordinaten überführen lassen. 
Von dort werden die Koordinaten mit der :code-block:`world_to_camera` Transformation 
in Kamerakoordinaten überführt, also die Koordinaten relativ zum Kamerakoordinatensystem. 

Beide Transformationen können über eine Kombination von Translationen, Skalierungen sowie 
Rotationen ausgedrückt werden. 

    

Die Projektion von 3D nach 2D
-----------------------------

Für die Projektion unserer 3D Koordinaten auf die zwei-dimensionale
Abbildungsebene verwenden wir das s.g. Pinhole-Kamera Model (Lochkameramodel).

.. image:: ./pinhole1.png
    :alt: Lochkameramodel
    :width: 600px
    :align: center

Punkte im 3D werden dabei über den `Strahlensatz <https://de.wikipedia.org/wiki/Strahlensatz>`_. 
abgebildet. Für einen Punkt :math:`P(x_1,x_2,x_3)`, wobei :math:`x_1` die vertikale Komponente und :math:`x_3` 
die longitudinale (Entfernung) darstellt finden wir die folgende Strahlensatzfigur

.. image:: ./pinhole3.png
    :alt: Lochkameramodel
    :width: 500px
    :align: center

und damit auch den Zusammenhang

.. math::
    \frac{-y_1}{f} = \frac{x_1}{x_3}

oder alternativ    

.. math::
    y_1 = \frac{-f\cdot x_1}{x_3}

Dabei ist :math:`f` die so genannte *Brennweite*. 
Für :math:`y_2` und :math:`x_2` findet sich ein entsprechender Zusammenhang. In homogenen 
Koordinaten ausgedrückt läßt sich diese Projektion darstellen als.

.. math::
    \begin{pmatrix}
    -c &  0 & 0 & 0\\
    0 & -c & 0 & 0\\
    0 &  0 & 1 & 0\\
    0 &  0 & 1 & 0
    \end{pmatrix}

Die so erhaltenden Koordinaten sind s.g. **Normalized Device Coordinates** (NDC)

.. image:: ./ndcspace.png
    :alt: Clipping-Koordinaten
    :width: 500px
    :align: center

Hierbei haben Punkte *vor* der Kamera ein :math:`z > 0` während Punkte *hinter* 
der Kamera ein :math:`z < 0` haben. Das wird später wichtig werden weil wir 
natürlich nur Punkte vor der Kamera zeichnen wollen. 

Abbildung in Bild-Koordinaten (Pixel)
-------------------------------------

Um die NDC-Koordinaten in Pixelkoordinaten für unser Zielbild zu transformieren 
multiplizieren wir zunächst mit der halben Bildbreite bzw. Höhe und verschieben 
den Mittelpunkt :math:`(0,0,0)` dann in die Bildmitte. Dazu benötigen wir die kombinierte 
Matrix

.. math::
    \begin{pmatrix}
    \frac{W}{2} & 0 & 0 & \frac{W}{2}\\
    0 & \frac{H}{2} & 0 & \frac{H}{2}\\
    0 & 0 & 1 & 0\\
    0 & 0 & 0 & 1
    \end{pmatrix}

Musterlösung
------------
.. autofunction:: homogen.identity_transform

:doc:`Homogene Koordinaten - Musterlösung <source>`