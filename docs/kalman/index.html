

<!DOCTYPE html>
<html class="writer-html5" lang="de">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Das Kalman-Filter &mdash; Machine Perception and Tracking - Praktikum  Dokumentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />

  
    <link rel="canonical" href="https://dmu1981.github.io/MPTPraktikum/kalman/index.html" />
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=cec59a4c"></script>
      <script src="../_static/doctools.js?v=888ff710"></script>
      <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
      <script src="../_static/translations.js?v=70a09b52"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Stichwortverzeichnis" href="../genindex.html" />
    <link rel="search" title="Suche" href="../search.html" />
    <link rel="prev" title="Der Vorwärts-Algorithmus" href="../forwardalgorithm/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Machine Perception and Tracking - Praktikum
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Dokumentation durchsuchen" aria-label="Dokumentation durchsuchen" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Aufgaben:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../webcam/index.html">Die Webcam öffnen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kanten/index.html">Kantendetektion mit Sobel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../harris/index.html">Der Harris Eckendetektor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../YOLO/index.html">Objekterkennung mit YOLO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AdaBoost/index.html">AdaBoost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HOG/index.html">Histogram of Oriented Gradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../homogen/index.html">Rechnen mit homogene Koordinaten</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mahalanobis/index.html">Mahalanobisdistanz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nonlinearmapping/index.html">Nichtlineare Abbildung normalverteilter Zufallsvariablen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../multivariate/index.html">Minimum Varianz Fusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../forwardalgorithm/index.html">Der Vorwärts-Algorithmus</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Das Kalman-Filter</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#einfuhrung-in-das-kalman-filter">Einführung in das Kalman-Filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#annahmen-des-kalman-filters">Annahmen des Kalman-Filters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#filtergleichungen-pradiktion-und-update">Filtergleichungen: Prädiktion und Update</a></li>
<li class="toctree-l2"><a class="reference internal" href="#initialisierung-des-kalman-filters">Initialisierung des Kalman-Filters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#beispiel-1-dimensionales-kalman-filter"><strong>Beispiel</strong>: 1-dimensionales Kalman-Filter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mehrere-messungen-zum-selben-zeitpunkt">Mehrere Messungen zum selben Zeitpunkt</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aufgabe-1"><strong>Aufgabe 1</strong></a></li>
<li class="toctree-l2"><a class="reference internal" href="#musterlosung">Musterlösung</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Machine Perception and Tracking - Praktikum</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Das Kalman-Filter</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/kalman/index.rst.txt" rel="nofollow"> Quelltext anzeigen</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="das-kalman-filter">
<h1>Das Kalman-Filter<a class="headerlink" href="#das-kalman-filter" title="Permalink to this heading"></a></h1>
<section id="einfuhrung-in-das-kalman-filter">
<h2>Einführung in das Kalman-Filter<a class="headerlink" href="#einfuhrung-in-das-kalman-filter" title="Permalink to this heading"></a></h2>
<p>Das Kalman-Filter ist ein rekursiver Schätzalgorithmus, der dazu verwendet wird, den Zustand eines dynamischen Systems aus einer Reihe unvollständiger und verrauschter Messdaten zu schätzen. Entwickelt wurde es in den 1960er Jahren von Rudolf E. Kálmán und hat seitdem breite Anwendung in verschiedenen technischen Disziplinen gefunden – von der Signalverarbeitung über die Robotik bis hin zur Navigation.</p>
<p>Im Kern kombiniert das Kalman-Filter ein mathematisches Modell des Systems mit tatsächlichen Messungen, um eine optimierte Schätzung des Systemzustands zu erzeugen. Es basiert auf zwei grundlegenden Phasen: der Vorhersage (Prädiktion) und der Korrektur (Update). In der Vorhersagephase wird der zukünftige Zustand des Systems auf Basis des Modells abgeschätzt. In der Korrekturphase wird diese Vorhersage mithilfe neuer Messdaten aktualisiert, wobei das Vertrauen in Modell und Messung durch Kovarianzmatrizen gesteuert wird.</p>
<p>Dank seiner Fähigkeit, auch bei starkem Messrauschen robuste Schätzungen zu liefern, ist das Kalman-Filter besonders in Anwendungen mit Echtzeitanforderungen und begrenzter Sensorpräzision unverzichtbar geworden.</p>
</section>
<section id="annahmen-des-kalman-filters">
<h2>Annahmen des Kalman-Filters<a class="headerlink" href="#annahmen-des-kalman-filters" title="Permalink to this heading"></a></h2>
<p>Damit das Kalman-Filter optimale Ergebnisse liefert, beruht es auf einer Reihe fundamentaler Annahmen über das zugrundeliegende System und die Messungen:</p>
<ol class="arabic">
<li><p><strong>Lineare Modelle</strong>
Sowohl das Zustandsmodell als auch das Messmodell müssen linear sein. Das bedeutet:</p>
<ul>
<li><p>Der Systemzustand entwickelt sich gemäß einer linearen Gleichung weiter:</p>
<div class="math notranslate nohighlight">
\[x_k = A x_{k-1} + B u_{k-1} + w_{k-1}\]</div>
</li>
<li><p>Die Messung hängt ebenfalls linear vom Zustand ab:</p>
<div class="math notranslate nohighlight">
\[z_k = H x_k + v_k\]</div>
</li>
</ul>
<p>Dabei sind <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span> und <span class="math notranslate nohighlight">\(H\)</span> bekannte Matrizen, <span class="math notranslate nohighlight">\(w_k\)</span> das Prozessrauschen und <span class="math notranslate nohighlight">\(v_k\)</span> das Messrauschen.</p>
</li>
<li><p><strong>Normalverteilte Zufallsgrößen</strong>
Sowohl das Prozessrauschen <span class="math notranslate nohighlight">\(w_k\)</span> als auch das Messrauschen <span class="math notranslate nohighlight">\(v_k\)</span> werden als <strong>weißes Rauschen mit Normalverteilung</strong> angenommen:</p>
<div class="math notranslate nohighlight">
\[w_k \sim \mathcal{N}(0, Q), \quad v_k \sim \mathcal{N}(0, R)\]</div>
<p>Diese Annahme stellt sicher, dass auch die geschätzten Zustände normalverteilt sind und das Filter eine geschlossene Form für Mittelwert und Kovarianz liefern kann.</p>
</li>
<li><p><strong>Unkorrelierte Rauschquellen</strong>
Das Prozess- und das Messrauschen sind voneinander <strong>unkorreliert</strong>:</p>
<div class="math notranslate nohighlight">
\[E[w_k v_j^T] = 0 \quad \text{für alle } k, j\]</div>
<p>Diese Unabhängigkeit ist entscheidend dafür, dass sich der Fehlerfortpflanzung sauber voneinander trennen lässt.</p>
</li>
<li><p><strong>Vollständige Kenntnis der Systemparameter</strong>
Die Modellmatrizen (<span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(B\)</span>, <span class="math notranslate nohighlight">\(H\)</span>), sowie die Kovarianzmatrizen des Rauschens (<span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span>) sind bekannt und konstant oder zumindest zeitabhängig aber vorab gegeben.</p></li>
</ol>
<p>Diese Voraussetzungen sind in vielen realen Anwendungen nur näherungsweise erfüllt. Dennoch liefert das Kalman-Filter auch bei leicht verletzten Annahmen oft brauchbare Resultate. Für nichtlineare oder nicht-Gaussverteilungen existieren Erweiterungen wie das Extended Kalman Filter (EKF) oder Unscented Kalman Filter (UKF).</p>
</section>
<section id="filtergleichungen-pradiktion-und-update">
<h2>Filtergleichungen: Prädiktion und Update<a class="headerlink" href="#filtergleichungen-pradiktion-und-update" title="Permalink to this heading"></a></h2>
<p>Das Kalman-Filter operiert in zwei Hauptphasen: <strong>Prädiktion (Vorhersage)</strong> und <strong>Update (Korrektur)</strong>. In jeder Zeitschrittiteration werden nacheinander diese beiden Schritte ausgeführt, um den Systemzustand möglichst genau zu schätzen.</p>
<p><strong>Prädiktionsschritt</strong></p>
<p>In der Prädiktionsphase wird der nächste Zustand des Systems basierend auf dem aktuellen Schätzwert und dem Modell vorhergesagt.</p>
<p><strong>Zustandsvorhersage:</strong></p>
<div class="math notranslate nohighlight">
\[\hat{x}_{k|k-1} = A \hat{x}_{k-1|k-1} + B u_{k-1}\]</div>
<p><strong>Fehlerkovarianz-Vorhersage:</strong></p>
<div class="math notranslate nohighlight">
\[P_{k|k-1} = A P_{k-1|k-1} A^T + Q\]</div>
<p>Hierbei bezeichnet:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\hat{x}_{k|k-1}\)</span> den vorhergesagten Zustand zum Zeitpunkt <span class="math notranslate nohighlight">\(k\)</span> basierend auf Information bis <span class="math notranslate nohighlight">\(k-1\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(P_{k|k-1}\)</span> die vorhergesagte Kovarianzmatrix</p></li>
<li><p><span class="math notranslate nohighlight">\(Q\)</span> die Kovarianzmatrix des Prozessrauschens</p></li>
</ul>
<p><strong>Updateschritt (Korrektur)</strong></p>
<p>Sobald eine neue Messung <span class="math notranslate nohighlight">\(z_k\)</span> eintrifft, wird die Vorhersage mit dieser Information korrigiert.</p>
<p><strong>Innovation (Messresiduum):</strong></p>
<div class="math notranslate nohighlight">
\[y_k = z_k - H \hat{x}_{k|k-1}\]</div>
<p><strong>Innovationskovarianz:</strong></p>
<div class="math notranslate nohighlight">
\[S_k = H P_{k|k-1} H^T + R\]</div>
<p><strong>Kalman-Gewinn:</strong></p>
<div class="math notranslate nohighlight">
\[K_k = P_{k|k-1} H^T S_k^{-1}\]</div>
<p><strong>Zustandsaktualisierung:</strong></p>
<div class="math notranslate nohighlight">
\[\hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k y_k\]</div>
<p><strong>Kovarianzaktualisierung:</strong></p>
<div class="math notranslate nohighlight">
\[P_{k|k} = (I - K_k H) P_{k|k-1}\]</div>
<p>Diese rekursive Struktur macht das Kalman-Filter besonders effizient, da es keine historischen Messdaten speichern muss. Stattdessen wird der Zustandsschätzer und die Kovarianzmatrix bei jedem neuen Schritt nur anhand der neuesten Informationen aktualisiert.</p>
</section>
<section id="initialisierung-des-kalman-filters">
<h2>Initialisierung des Kalman-Filters<a class="headerlink" href="#initialisierung-des-kalman-filters" title="Permalink to this heading"></a></h2>
<p>Bevor das Kalman-Filter mit der rekursiven Schätzung beginnen kann, müssen der anfängliche Zustand und seine Unsicherheit spezifiziert werden. Diese <strong>Initialisierung</strong> spielt eine wichtige Rolle für die Konvergenzgeschwindigkeit und Genauigkeit des Filters in den ersten Zeitschritten.</p>
<p><strong>Zustandsschätzung aus der ersten Messung</strong></p>
<p>In vielen praktischen Anwendungen liegen keine exakten Informationen über den Anfangszustand vor. Eine gängige Methode besteht daher darin, den <strong>ersten Messwert</strong> <span class="math notranslate nohighlight">\(z_0\)</span> als Startpunkt für die Zustandsschätzung zu verwenden. Dazu wird angenommen, dass der Messwert bereits eine (ggf. verrauschte) Beobachtung des tatsächlichen Zustands ist:</p>
<div class="math notranslate nohighlight">
\[\hat{x}_{0|0} = H^{-1} z_0\]</div>
<p>Falls <span class="math notranslate nohighlight">\(H\)</span> nicht invertierbar ist (z. B. bei nicht-vollständiger Beobachtung), kann alternativ eine Annäherung oder Projektion auf den beobachtbaren Raum genutzt werden. In vielen Fällen wird auch direkt gesetzt:</p>
<div class="math notranslate nohighlight">
\[\hat{x}_{0|0} = z_0\]</div>
<p>sofern das Messmodell <span class="math notranslate nohighlight">\(H = I\)</span> (Identitätsmatrix) ist, also der Messwert direkt dem Zustand entspricht.</p>
<p><strong>Initiale Kovarianzmatrix</strong></p>
<p>Die anfängliche Unsicherheit über den Zustand wird durch die Kovarianzmatrix <span class="math notranslate nohighlight">\(P_{0|0}\)</span> beschrieben. Diese sollte so gewählt werden, dass sie die Unsicherheit der Startschätzung realistisch widerspiegelt:</p>
<ul class="simple">
<li><p>Ist der Anfangszustand <strong>präzise bekannt</strong>, kann <span class="math notranslate nohighlight">\(P_{0|0}\)</span> klein gewählt werden (z. B. <span class="math notranslate nohighlight">\(P_{0|0} = 0\)</span>).</p></li>
<li><p>Ist der Anfangszustand <strong>unsicher</strong>, sollte <span class="math notranslate nohighlight">\(P_{0|0}\)</span> große Werte enthalten (z. B. eine skalierte Einheitsmatrix mit großem Faktor).</p></li>
</ul>
<p>Ein typischer Initialwert ist:</p>
<div class="math notranslate nohighlight">
\[P_{0|0} = \sigma^2 I\]</div>
<p>wobei <span class="math notranslate nohighlight">\(\sigma^2\)</span> eine heuristisch gewählte Anfangsvarianz ist.</p>
<p><strong>Bemerkung zur Konvergenz</strong></p>
<p>Auch wenn die Initialisierung ungenau ist, konvergiert das Kalman-Filter bei hinreichend informativen Messdaten in der Regel nach einigen Schritten gegen die optimale Schätzung. Dennoch kann eine sinnvolle Initialisierung das Verhalten in der Anfangsphase stark verbessern.</p>
</section>
<section id="beispiel-1-dimensionales-kalman-filter">
<h2><strong>Beispiel</strong>: 1-dimensionales Kalman-Filter<a class="headerlink" href="#beispiel-1-dimensionales-kalman-filter" title="Permalink to this heading"></a></h2>
<p>Dieses Beispiel zeigt die Funktionsweise des Kalman-Filters in einem einfachen 1D-Szenario, in dem der Zustand die Position eines sich gleichförmig bewegenden Objekts beschreibt. Wir nehmen an:</p>
<ul class="simple">
<li><p>Der Zustand ist die Position <span class="math notranslate nohighlight">\(x\)</span>.</p></li>
<li><p>Es gibt keine Kontrolleingabe <span class="math notranslate nohighlight">\(u\)</span>.</p></li>
<li><p>Das Systemmodell lautet: <span class="math notranslate nohighlight">\(x_k = x_{k-1} + w_k\)</span> mit <span class="math notranslate nohighlight">\(w_k \sim \mathcal{N}(0, Q)\)</span></p></li>
<li><p>Das Messmodell lautet: <span class="math notranslate nohighlight">\(z_k = x_k + v_k\)</span> mit <span class="math notranslate nohighlight">\(v_k \sim \mathcal{N}(0, R)\)</span></p></li>
</ul>
<p><strong>Gegeben:</strong></p>
<ul class="simple">
<li><p>Anfangsschätzung: <span class="math notranslate nohighlight">\(\hat{x}_{0|0} = 0\)</span></p></li>
<li><p>Anfangskovarianz: <span class="math notranslate nohighlight">\(P_{0|0} = 1.0\)</span></p></li>
<li><p>Prozessrauschen: <span class="math notranslate nohighlight">\(Q = 1.0\)</span></p></li>
<li><p>Messrauschen: <span class="math notranslate nohighlight">\(R = 2.0\)</span></p></li>
<li><p>Messwert bei <span class="math notranslate nohighlight">\(k=1\)</span>: <span class="math notranslate nohighlight">\(z_1 = 1.2\)</span></p></li>
</ul>
<p>—</p>
<p><strong>Schritt 1: Prädiktion</strong></p>
<div class="math notranslate nohighlight">
\[\hat{x}_{1|0} = \hat{x}_{0|0} = 0.0\]</div>
<div class="math notranslate nohighlight">
\[P_{1|0} = P_{0|0} + Q = 1.0 + 1.0 = 2.0\]</div>
<p>—</p>
<p><strong>Schritt 2: Update</strong></p>
<p><strong>Innovation:</strong></p>
<div class="math notranslate nohighlight">
\[y_1 = z_1 - \hat{x}_{1|0} = 1.2 - 0.0 = 1.2\]</div>
<p><strong>Innovationskovarianz:</strong></p>
<div class="math notranslate nohighlight">
\[S_1 = P_{1|0} + R = 2.0 + 2.0 = 4.0\]</div>
<p><strong>Kalman-Gewinn:</strong></p>
<div class="math notranslate nohighlight">
\[K_1 = \frac{P_{1|0}}{S_1} = \frac{2.0}{4.0} = 0.5\]</div>
<p><strong>Zustandsaktualisierung:</strong></p>
<div class="math notranslate nohighlight">
\[\hat{x}_{1|1} = \hat{x}_{1|0} + K_1 \cdot y_1 = 0.0 + 0.5 \cdot 1.2 = 0.6\]</div>
<p><strong>Kovarianzaktualisierung:</strong></p>
<div class="math notranslate nohighlight">
\[P_{1|1} = (1 - K_1) \cdot P_{1|0} = (1 - 0.5) \cdot 2.0 = 1.0\]</div>
<p><strong>Ergebnis nach Schritt 1:</strong></p>
<ul class="simple">
<li><p>Geschätzte Position: <span class="math notranslate nohighlight">\(\hat{x}_{1|1} = 0.6\)</span></p></li>
<li><p>Unsicherheit: <span class="math notranslate nohighlight">\(P_{1|1} = 1.0\)</span></p></li>
</ul>
<p><strong>Anmerkung:</strong>
Dieses einfache Beispiel zeigt, wie das Kalman-Filter Messwerte mit Modellvorhersagen kombiniert. Die Schätzung liegt zwischen dem Modell (0.0) und der Messung (1.2), gewichtet durch das Vertrauen in beide Quellen. Da Mess- und Modellunsicherheit gleich groß sind, wird der Mittelwert gewählt.</p>
<p>Weitere Iterationen würden nach dem gleichen Schema fortfahren.</p>
</section>
<section id="mehrere-messungen-zum-selben-zeitpunkt">
<h2>Mehrere Messungen zum selben Zeitpunkt<a class="headerlink" href="#mehrere-messungen-zum-selben-zeitpunkt" title="Permalink to this heading"></a></h2>
<p>In vielen praktischen Anwendungen stehen mehrere Sensoren zur Verfügung, die <strong>zeitgleich</strong> Informationen über denselben Systemzustand liefern. Typische Beispiele sind GPS-, Lidar- und Radarsensoren in autonomen Fahrzeugen. Das Kalman-Filter lässt sich auf diese Situation elegant erweitern.</p>
<p><strong>Grundidee</strong></p>
<p>Wenn mehrere Messungen <span class="math notranslate nohighlight">\(z_k^{(1)}, z_k^{(2)}, \dots, z_k^{(n)}\)</span> zum gleichen Zeitpunkt vorliegen, können diese entweder:</p>
<ol class="arabic">
<li><p><strong>Gemeinsam in einem erweiterten Messvektor</strong> verarbeitet werden:</p>
<div class="math notranslate nohighlight">
\[\begin{split}z_k = \begin{bmatrix} z_k^{(1)} \\ z_k^{(2)} \\ \vdots \\ z_k^{(n)} \end{bmatrix}, \quad
H = \begin{bmatrix} H^{(1)} \\ H^{(2)} \\ \vdots \\ H^{(n)} \end{bmatrix}, \quad
R = \begin{bmatrix} R^{(1)} &amp;        &amp;        \\
                        &amp; \ddots &amp;        \\
                        &amp;        &amp; R^{(n)} \end{bmatrix}\end{split}\]</div>
<p>Dies führt zu einem einzigen Update-Schritt mit aggregierter Information.</p>
</li>
<li><p><strong>Sequentiell nacheinander</strong> verarbeitet werden – mit jeweils eigenem Update:</p>
<ul class="simple">
<li><p>Nach jeder Messung wird der Zustand aktualisiert.</p></li>
<li><p>Der nächste Sensor nutzt den bereits verbesserten Schätzwert als Ausgangspunkt.</p></li>
</ul>
</li>
</ol>
<p><strong>Vergleich und Anwendung</strong></p>
<ul class="simple">
<li><p>Die <strong>gemeinsame Verarbeitung</strong> (Option 1) ist effizienter und optimal unter der Annahme, dass die Messungen unkorreliert sind.</p></li>
<li><p>Die <strong>sequentielle Verarbeitung</strong> (Option 2) ist flexibler und erlaubt z. B. unterschiedliche Messraten oder unsortierten Eingang.</p></li>
</ul>
<p>Beide Methoden liefern bei korrekt spezifizierten Modellen und Rauschkovarianzen identische Resultate, solange die Messfehler unabhängig sind.</p>
</section>
<section id="aufgabe-1">
<h2><strong>Aufgabe 1</strong><a class="headerlink" href="#aufgabe-1" title="Permalink to this heading"></a></h2>
<p>Den Filter initialisieren.</p>
<p>Implementieren Sie eine nun die Funktion <code class="xref py py-meth docutils literal notranslate"><span class="pre">kalman.kalman.init_filter()</span></code>. Folgen Sie den
Anweisungen im Code sowie dieser Beschreibung.</p>
</section>
<section id="musterlosung">
<h2>Musterlösung<a class="headerlink" href="#musterlosung" title="Permalink to this heading"></a></h2>
<p><a class="reference internal" href="source.html"><span class="doc">Das Kalman-Filter - Musterlösung</span></a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../forwardalgorithm/index.html" class="btn btn-neutral float-left" title="Der Vorwärts-Algorithmus" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Zurück</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Prof. Dr. Dennis Müller.</p>
  </div>

  Erstellt mit <a href="https://www.sphinx-doc.org/">Sphinx</a> mit einem
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    bereitgestellt von <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>