

<!DOCTYPE html>
<html class="writer-html5" lang="de" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Homogene Koordinaten &mdash; Machine Perception and Tracking - Praktikum  Dokumentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />

  
    <link rel="canonical" href="https://dmu1981.github.io/MPTPraktikum/homogen/index.html" />
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=245627df"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
      <script src="../_static/translations.js?v=79cc9f76"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Stichwortverzeichnis" href="../genindex.html" />
    <link rel="search" title="Suche" href="../search.html" />
    <link rel="next" title="Mahalanobis-Distanz und Kovarianzellipsen" href="../mahalanobis/index.html" />
    <link rel="prev" title="Histogram of Oriented Gradients" href="../HOG/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Machine Perception and Tracking - Praktikum
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Dokumentation durchsuchen" aria-label="Dokumentation durchsuchen" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Aufgaben:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../webcam/index.html">Die Webcam öffnen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kanten/index.html">Kantendetektion mit Sobel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../harris/index.html">Der Harris Eckendetektor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../YOLO/index.html">Objekterkennung mit YOLO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AdaBoost/index.html">AdaBoost</a></li>
<li class="toctree-l1"><a class="reference internal" href="../HOG/index.html">Histogram of Oriented Gradients</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Rechnen mit homogene Koordinaten</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#der-code">Der Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#unsere-eigene-kleine-3d-rendering-engine">Unsere eigene kleine 3D Rendering Engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="#einmal-von-euklidisch-nach-homogen-und-zuruck">Einmal von euklidisch nach homogen und zurück</a></li>
<li class="toctree-l2"><a class="reference internal" href="#translationen-in-homogenen-koordinaten">Translationen in homogenen Koordinaten</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aufgabe-implementieren-sie-die-funktion-translate-3d"><strong>Aufgabe</strong>: Implementieren Sie die Funktion <em>translate_3d</em></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#skalierung-in-homogenen-koordinaten">Skalierung in homogenen Koordinaten</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aufgabe-implementieren-sie-die-funktion-scale"><strong>Aufgabe</strong>: Implementieren Sie die Funktion <em>scale</em></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mehrere-transformationen-zusammenfassen">Mehrere Transformationen zusammenfassen</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rotationen">Rotationen</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aufgabe-implementieren-sie-die-funktionen-rotatex-rotatey-und-rotatez"><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>rotateX</em>, <em>rotateY</em> und <em>rotateZ</em></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#auf-die-reihenfolge-kommt-es-an">Auf die Reihenfolge kommt es an</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aufgabe-implementieren-sie-die-funktionen-rotatexyz"><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>rotateXYZ</em></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#die-projektion-von-3d-nach-2d">Die Projektion von 3D nach 2D</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aufgabe-implementieren-sie-die-funktionen-projection"><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>projection</em></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#abbildung-in-bild-koordinaten-pixel">Abbildung in Bild-Koordinaten (Pixel)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aufgabe-implementieren-sie-die-funktionen-ndc-to-image"><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>ndc_to_image</em></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#die-kameramatrix">Die Kameramatrix</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aufgabe-implementieren-sie-die-funktionen-world-to-camera"><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>world_to_camera</em></a></li>
<li class="toctree-l3"><a class="reference internal" href="#von-lokalen-koordinaten-nach-weltkoordinaten">Von lokalen Koordinaten nach Weltkoordinaten</a></li>
<li class="toctree-l3"><a class="reference internal" href="#aufgabe-implementieren-sie-die-funktionen-local-to-world"><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>local_to_world</em></a></li>
<li class="toctree-l3"><a class="reference internal" href="#von-weltkoordiaten-nach-bildkoordinaten">Von Weltkoordiaten nach Bildkoordinaten</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id1"><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>world_to_camera</em></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#die-datenstruktur-fur-geometriedaten">Die Datenstruktur für Geometriedaten</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aufgabe-implementieren-sie-die-funktionen-project-vertexbuffer"><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>project_vertexbuffer</em></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#die-vertices-zeichnen">Die Vertices zeichnen</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#aufgabe-implementieren-sie-die-funktionen-draw"><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>draw</em></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#musterlosung">Musterlösung</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mahalanobis/index.html">Mahalanobisdistanz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nonlinearmapping/index.html">Nichtlineare Abbildung normalverteilter Zufallsvariablen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../multivariate/index.html">Minimum Varianz Fusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../forwardalgorithm/index.html">Der Vorwärts-Algorithmus</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Machine Perception and Tracking - Praktikum</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Homogene Koordinaten</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/homogen/index.rst.txt" rel="nofollow"> Quelltext anzeigen</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="homogene-koordinaten">
<h1>Homogene Koordinaten<a class="headerlink" href="#homogene-koordinaten" title="Link to this heading"></a></h1>
<p>Homogene Koordinaten erlauben es Verschiebungen (Translation), Rotationen (Drehungen) sowie Skalierungen (Größenänderung)
einheitlich über Matrixmultiplikationen abzubilden. Die Verkettung mehrerer
solcher Operationen läßt sich dann mit Hilfe des Assoziativgesetzes zu einer einzigen
Matrix zusammenfassen. Die perspektivische Projektion von 3D Koordinaten auf eine
zwei-dimensionale Ebene (Pinhole Kamera) läßt sich ebenfalls durch eine entsprechende Matrixmultiplikation
ausdrücken. Damit lässt sich die gesame Abbildung von Objektlokalen 3D Koordinaten in Sensorlokale 2D Koordinaten
direkt über eine einzige Matrix-Multiplikation ausdrücken. In diesem Praktikum
betrachten wir diese Abbildungsmöglichkeiten. Wir entwickeln unsere eigene kleine 3D-Engine, welche 3D-Koordinaten
über eine simulierte Kamera auf ein Bild umrechnet und damit Objekte zeichnet.</p>
<a class="reference internal image-reference" href="../_images/screenshot.jpg"><img alt="3D Abbildungen" class="align-center" src="../_images/screenshot.jpg" style="width: 1024px;" />
</a>
<section id="der-code">
<h2>Der Code<a class="headerlink" href="#der-code" title="Link to this heading"></a></h2>
<p>Für dieses Praktikum arbeiten Sie in der Datei</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">homogen</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>und implementieren nach und nach die verschiedenen Methoden. Die Erklärungen in diesem Dokument sollen Ihnen dabei helfen.</p>
</section>
<section id="unsere-eigene-kleine-3d-rendering-engine">
<h2>Unsere eigene kleine 3D Rendering Engine<a class="headerlink" href="#unsere-eigene-kleine-3d-rendering-engine" title="Link to this heading"></a></h2>
<p>In diesem Praktikum wollen wir eine einfache kleine 3D Rendering Engine
implementieren welche Punkte im 3D über eine Kamera in 2D-Koordinaten überführt und zeichnet.
Dazu orientieren wir uns stark an dem von <a class="reference external" href="https://learnopengl.com/Getting-started/Coordinate-Systems">OpenGL</a>
verwendeten Ansatz und betrachten im folgenden fünf verschiedene Koordinatensystem.</p>
<a class="reference internal image-reference" href="../_images/coordinate_systems.png"><img alt="Koordinatensysteme" class="align-center" src="../_images/coordinate_systems.png" style="width: 800px;" />
</a>
<ul class="simple">
<li><p>Lokale Koordinaten sind die Koordinaten des Objekts relativ zu seinem lokalen Ursprung; das sind die Koordinaten, in denen sich das Objekt anfangs befindet.</p></li>
<li><p>Der nächste Schritt besteht darin, die lokalen Koordinaten in Weltkoordinaten zu transformieren, also Koordinaten im Bezug auf eine globale Welt. Diese Koordinaten sind relativ zu einem globalen Ursprung der Welt, zusammen mit vielen anderen Objekten, die ebenfalls relativ zu diesem Weltursprung platziert sind.</p></li>
<li><p>Als Nächstes transformieren wir die Weltkoordinaten in Ansichtskoordinaten (View-Space-Koordinaten), sodass jede Koordinate aus der Sicht der Kamera oder des Betrachters dargestellt wird.</p></li>
<li><p>Nachdem sich die Koordinaten im View-Space befinden, möchten wir sie in NDC-Koordinaten projizieren. NDC-Koordinaten werden auf den Bereich von -1,0 bis 1,0 normiert und bestimmen, welche Scheitelpunkte (Vertices) letztlich auf dem Bildschirm erscheinen.</p></li>
<li><p>Schließlich transformieren wir die NDC-Koordinaten in Bildschirmkoordinaten. Dabei werden die Koordinaten von -1,0 bis 1,0 in Pixelkoordiaten im Zielbild überführt.</p></li>
</ul>
</section>
<section id="einmal-von-euklidisch-nach-homogen-und-zuruck">
<h2>Einmal von euklidisch nach homogen und zurück<a class="headerlink" href="#einmal-von-euklidisch-nach-homogen-und-zuruck" title="Link to this heading"></a></h2>
<p>Eine Darstellung <span class="math notranslate nohighlight">\(\mathcal{p}\)</span> heißt <em>homogen</em>, wenn für alle <span class="math notranslate nohighlight">\(\lambda\neq 0\)</span>
gilt :</p>
<div class="math notranslate nohighlight">
\[\mathcal{p} = \lambda \mathcal{p}\]</div>
<p>beschreibt das selbe Objekt. Für einen Punkt in euklischen Koordinaten</p>
<div class="math notranslate nohighlight">
\[\textbf{p} = (x_p, y_p, z_p)\]</div>
<p>schreiben wir in homogenen Koordinaten</p>
<div class="math notranslate nohighlight">
\[\mathcal{p} = (x_p, y_p, z_p, 1)\]</div>
<p>d.h. wir fügen eine Konstante 1 in der letzten Komponente an. Diese letzte Komponente
nennen wir einheitlich <span class="math notranslate nohighlight">\(w\)</span>.</p>
<p>Um eine homogene Koordinate <span class="math notranslate nohighlight">\(\mathcal{q}=(x_q, y_q, z_q, w_q)\)</span> wieder in euklische Koordinaten
zu überführen dividieren wir durch die <span class="math notranslate nohighlight">\(w\)</span>-Komponente und erhalten</p>
<div class="math notranslate nohighlight">
\[\textbf{q} = (x_q / w_q, y_q / w_q, z_q / w_q)\]</div>
</section>
<section id="translationen-in-homogenen-koordinaten">
<h2>Translationen in homogenen Koordinaten<a class="headerlink" href="#translationen-in-homogenen-koordinaten" title="Link to this heading"></a></h2>
<p>Um einen Punkt <span class="math notranslate nohighlight">\(\textbf{p}\)</span> in homogenen Koordinaten um einen Vektor
<span class="math notranslate nohighlight">\(\vec v\)</span> zu verschieben multiplizieren wir mit der folgenden Matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; x_v\\
    0 &amp; 1 &amp; 0 &amp; y_v\\
    0 &amp; 0 &amp; 1 &amp; z_v\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}\cdot
\begin{pmatrix}
x_p\\y_p\\z_p\\1
\end{pmatrix}
=
\begin{pmatrix}
x_p + x_v\\y_p + y_v\\z_p + z_v\\1
\end{pmatrix}\end{split}\]</div>
<section id="aufgabe-implementieren-sie-die-funktion-translate-3d">
<h3><strong>Aufgabe</strong>: Implementieren Sie die Funktion <em>translate_3d</em><a class="headerlink" href="#aufgabe-implementieren-sie-die-funktion-translate-3d" title="Link to this heading"></a></h3>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">translate_3d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
      <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
  <span class="p">])</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="skalierung-in-homogenen-koordinaten">
<h2>Skalierung in homogenen Koordinaten<a class="headerlink" href="#skalierung-in-homogenen-koordinaten" title="Link to this heading"></a></h2>
<p>Um einen Punkt <span class="math notranslate nohighlight">\(\textbf{p}\)</span> in homogenen Koordinaten entlang der
Hauptachsen zu skalieren (relativ zum Urspung <span class="math notranslate nohighlight">\((0,0,0)\)</span>) multiplizieren wir mit der folgenden Matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    x_s &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; y_s &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; z_s &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}\cdot
\begin{pmatrix}
x_p\\y_p\\z_p\\1
\end{pmatrix}
=
\begin{pmatrix}
x_s \cdot x_p\\y_s \cdot y_p\\z_s \cdot z_p\\1
\end{pmatrix}\end{split}\]</div>
<section id="aufgabe-implementieren-sie-die-funktion-scale">
<h3><strong>Aufgabe</strong>: Implementieren Sie die Funktion <em>scale</em><a class="headerlink" href="#aufgabe-implementieren-sie-die-funktion-scale" title="Link to this heading"></a></h3>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">scale</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
      <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
      <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
  <span class="p">])</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="mehrere-transformationen-zusammenfassen">
<h2>Mehrere Transformationen zusammenfassen<a class="headerlink" href="#mehrere-transformationen-zusammenfassen" title="Link to this heading"></a></h2>
<p>Um mehrere Transformationen nacheinander auszuführen multiplizieren
wir die entsprechenden Transformationsmatrizen jeweils <strong>von links</strong>.
Dabei spielt die Reihenfolge eine Rolle (Matrix-Multiplikation ist nicht kommutativ),
die jeweils weiter rechts stehende Matrix wird dabei zuerst ausgeführt.</p>
<p><strong>Beispiel</strong>: Zuerst verschieben, dann skalieren</p>
<p>Wollen wir den Punkt <span class="math notranslate nohighlight">\((1,2,3)\)</span> zuerst um den Vektor <span class="math notranslate nohighlight">\((-2, -2, -2)\)</span> verschieben und dann um den Faktor 4 gleichmässig skalieren, multiplizieren wir mit den
folgenden Matrizen</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    4 &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; 4 &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; 4 &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\cdot
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; -2\\
    0 &amp; 1 &amp; 0 &amp; -2\\
    0 &amp; 0 &amp; 1 &amp; -2\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\cdot
\begin{pmatrix}
    1\\2\\3\\1
\end{pmatrix}\end{split}\]</div>
<p>Multiplizieren wir <strong>manuell</strong> von rechts nach links finden wir zunächst den verschobenen Punkt</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; -2\\
    0 &amp; 1 &amp; 0 &amp; -2\\
    0 &amp; 0 &amp; 1 &amp; -2\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\cdot
\begin{pmatrix}
    1\\2\\3\\1
\end{pmatrix}
=
\begin{pmatrix}
    -1\\0\\1\\1
\end{pmatrix}\end{split}\]</div>
<p>Nach Skalierung finden wir dann mit</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    4 &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; 4 &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; 4 &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\cdot
\begin{pmatrix}
    -1\\0\\1\\1
\end{pmatrix}
=
\begin{pmatrix}
    -4\\0\\4\\1
\end{pmatrix}\end{split}\]</div>
<p>den finalen Punkt. Alternativ können wir mit dem Assoziativgesetz auch die
beiden Matrix zuerst multiplizieren und finden</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    4 &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; 4 &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; 4 &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\cdot
\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; -2\\
    0 &amp; 1 &amp; 0 &amp; -2\\
    0 &amp; 0 &amp; 1 &amp; -2\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
=
\begin{pmatrix}
    4 &amp; 0 &amp; 0 &amp; -8\\
    0 &amp; 4 &amp; 0 &amp; -8\\
    0 &amp; 0 &amp; 4 &amp; -8\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}\end{split}\]</div>
<p>Diese Matrix kodiert die Kombination aus beiden Transformationen in der richtigen Reihenfolge.</p>
<p><strong>Beispiel</strong>: Zuerst skalieren, dann verschieben</p>
<p>Vertauschen wir die Reihenfolge
indem wir den Punkt <span class="math notranslate nohighlight">\((1,2,3)\)</span> zuerst um den Faktor 4 gleichmäßig skalieren und dann
um den Vektor <span class="math notranslate nohighlight">\((-2, -2, -2)\)</span> verschieben, vertauschen wir die Matrizen</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; -2\\
    0 &amp; 1 &amp; 0 &amp; -2\\
    0 &amp; 0 &amp; 1 &amp; -2\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\cdot
\begin{pmatrix}
    4 &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; 4 &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; 4 &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\cdot
\begin{pmatrix}
    1\\2\\3\\1
\end{pmatrix}\end{split}\]</div>
<p>Multiplizieren wir wieder die Matrizen zuerst, finden wir eine andere Abbildungsmatrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; -2\\
    0 &amp; 1 &amp; 0 &amp; -2\\
    0 &amp; 0 &amp; 1 &amp; -2\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
\cdot
\begin{pmatrix}
    4 &amp; 0 &amp; 0 &amp; 0\\
    0 &amp; 4 &amp; 0 &amp; 0\\
    0 &amp; 0 &amp; 4 &amp; 0\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}
=
\begin{pmatrix}
    4 &amp; 0 &amp; 0 &amp; -2\\
    0 &amp; 4 &amp; 0 &amp; -2\\
    0 &amp; 0 &amp; 4 &amp; -2\\
    0 &amp; 0 &amp; 0 &amp; 1\\
\end{pmatrix}\end{split}\]</div>
<p><strong>Hinweis</strong>: In Python können wir zwei Matrizen mit dem <cite>&#64;</cite>-Operator multiplizieren, also</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">B</span>
</pre></div>
</div>
</section>
<section id="rotationen">
<h2>Rotationen<a class="headerlink" href="#rotationen" title="Link to this heading"></a></h2>
<p>Um einen Punkt um den Ursprung um die X-Achse zu rotieren verwenden wir die folgende Rotationsmatrix:</p>
<div class="math notranslate nohighlight">
\[\begin{split}R_x(\alpha) =
\begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0\\
0 &amp; \cos(\alpha) &amp; -\sin(\alpha) &amp; 0\\
0 &amp; \sin(\alpha) &amp;  \cos(\alpha) &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\end{split}\]</div>
<p>Für eine Rotation um die Y-Achse verwenden wir die folgende Matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}R_y(\alpha) =
\begin{pmatrix}
\cos(\alpha) &amp; 0 &amp; \sin(\alpha) &amp; 0\\
0 &amp; 1 &amp; 0 &amp; 0\\
-\sin(\alpha) &amp; 0 &amp;  \cos(\alpha) &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\end{split}\]</div>
<p>Für eine Rotation um die Z-Achse verwenden wir die folgende Matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}R_z(\alpha) =
\begin{pmatrix}
\cos(\alpha) &amp; -\sin(\alpha) &amp; 0 &amp; 0\\
\sin(\alpha) &amp; \cos(\alpha) &amp; 0 &amp; 0\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\end{split}\]</div>
<section id="aufgabe-implementieren-sie-die-funktionen-rotatex-rotatey-und-rotatez">
<h3><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>rotateX</em>, <em>rotateY</em> und <em>rotateZ</em><a class="headerlink" href="#aufgabe-implementieren-sie-die-funktionen-rotatex-rotatey-und-rotatez" title="Link to this heading"></a></h3>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">rotateX</span><span class="p">(</span><span class="n">radians</span><span class="p">):</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span>   <span class="n">c</span><span class="p">,</span>  <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span>   <span class="n">s</span><span class="p">,</span>   <span class="n">c</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
    <span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">rotateY</span><span class="p">(</span><span class="n">radians</span><span class="p">):</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span>  <span class="n">c</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>   <span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>   <span class="n">c</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
    <span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">rotateZ</span><span class="p">(</span><span class="n">radians</span><span class="p">):</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span>   <span class="n">c</span><span class="p">,</span>  <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span>   <span class="n">s</span><span class="p">,</span>   <span class="n">c</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
    <span class="p">])</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="auf-die-reihenfolge-kommt-es-an">
<h2>Auf die Reihenfolge kommt es an<a class="headerlink" href="#auf-die-reihenfolge-kommt-es-an" title="Link to this heading"></a></h2>
<p>Die Reihenfolge der Rotationen spielt eine Rolle. Daher gibt es die allgemeine Konvention Rotationen nach dem Schema</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Roll</span> <span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">Pitch</span> <span class="p">(</span><span class="n">Y</span><span class="p">)</span> <span class="o">-</span> <span class="n">Yaw</span> <span class="p">(</span><span class="n">Z</span><span class="p">)</span>
</pre></div>
</div>
<p>umzusetzen.</p>
<a class="reference internal image-reference" href="../_images/rollpitchyaw.png"><img alt="Roll - Pich - Yaw" class="align-center" src="../_images/rollpitchyaw.png" style="width: 600px;" />
</a>
<section id="aufgabe-implementieren-sie-die-funktionen-rotatexyz">
<h3><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>rotateXYZ</em><a class="headerlink" href="#aufgabe-implementieren-sie-die-funktionen-rotatexyz" title="Link to this heading"></a></h3>
<p>Implementieren Sie nun die Funktion <em>rotateXYZ</em>, indem Sie die die Funktionen
<code class="xref py py-func docutils literal notranslate"><span class="pre">homogen.rotateX()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">homogen.rotateY()</span></code> und <code class="xref py py-func docutils literal notranslate"><span class="pre">homogen.rotateZ()</span></code> in der korrekten Reihenfolge anwenden.</p>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">rotateXYZ</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">rotateZ</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">@</span> <span class="n">rotateY</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">@</span> <span class="n">rotateX</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="die-projektion-von-3d-nach-2d">
<h2>Die Projektion von 3D nach 2D<a class="headerlink" href="#die-projektion-von-3d-nach-2d" title="Link to this heading"></a></h2>
<p>Für die Projektion unserer 3D Koordinaten auf die zwei-dimensionale
Abbildungsebene verwenden wir das s.g. Pinhole-Kamera Model (Lochkameramodel).</p>
<a class="reference internal image-reference" href="../_images/pinhole1.png"><img alt="Lochkameramodel" class="align-center" src="../_images/pinhole1.png" style="width: 600px;" />
</a>
<p>Punkte im 3D werden dabei über den <a class="reference external" href="https://de.wikipedia.org/wiki/Strahlensatz">Strahlensatz</a>.
abgebildet. Für einen Punkt <span class="math notranslate nohighlight">\(P(x_1,x_2,x_3)\)</span>, wobei <span class="math notranslate nohighlight">\(x_1\)</span> die vertikale Komponente und <span class="math notranslate nohighlight">\(x_3\)</span>
die longitudinale (Entfernung) darstellt finden wir die folgende Strahlensatzfigur</p>
<a class="reference internal image-reference" href="../_images/pinhole3.png"><img alt="Lochkameramodel" class="align-center" src="../_images/pinhole3.png" style="width: 500px;" />
</a>
<p>und damit auch den Zusammenhang</p>
<div class="math notranslate nohighlight">
\[\frac{-y_1}{f} = \frac{x_1}{x_3}\]</div>
<p>oder alternativ</p>
<div class="math notranslate nohighlight">
\[y_1 = \frac{-f\cdot x_1}{x_3}\]</div>
<p>Dabei ist <span class="math notranslate nohighlight">\(f\)</span> die so genannte <em>Brennweite</em>.
Für <span class="math notranslate nohighlight">\(y_2\)</span> und <span class="math notranslate nohighlight">\(x_2\)</span> findet sich ein entsprechender Zusammenhang. In homogenen
Koordinaten ausgedrückt läßt sich diese Projektion darstellen als.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
-c &amp;  0 &amp; 0 &amp; 0\\
0 &amp; -c &amp; 0 &amp; 0\\
0 &amp;  0 &amp; 1 &amp; 0\\
0 &amp;  0 &amp; 1 &amp; 0
\end{pmatrix}\end{split}\]</div>
<p>Die so erhaltenden Koordinaten sind s.g. <strong>Normalized Device Coordinates</strong> (NDC)</p>
<a class="reference internal image-reference" href="../_images/ndcspace.png"><img alt="Clipping-Koordinaten" class="align-center" src="../_images/ndcspace.png" style="width: 500px;" />
</a>
<p>Hierbei haben Punkte <em>vor</em> der Kamera ein <span class="math notranslate nohighlight">\(z &gt; 0\)</span> während Punkte <em>hinter</em>
der Kamera ein <span class="math notranslate nohighlight">\(z &lt; 0\)</span> haben. Das wird später wichtig werden weil wir
natürlich nur Punkte vor der Kamera zeichnen wollen.</p>
<section id="aufgabe-implementieren-sie-die-funktionen-projection">
<h3><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>projection</em><a class="headerlink" href="#aufgabe-implementieren-sie-die-funktionen-projection" title="Link to this heading"></a></h3>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">projection</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
            <span class="p">[</span><span class="o">-</span><span class="n">c</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>   <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">c</span><span class="p">,</span>   <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">]</span>
        <span class="p">])</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="abbildung-in-bild-koordinaten-pixel">
<h2>Abbildung in Bild-Koordinaten (Pixel)<a class="headerlink" href="#abbildung-in-bild-koordinaten-pixel" title="Link to this heading"></a></h2>
<p>Um die NDC-Koordinaten in Pixelkoordinaten für unser Zielbild zu transformieren
multiplizieren wir zunächst mit der halben Bildbreite bzw. Höhe und verschieben
den Mittelpunkt <span class="math notranslate nohighlight">\((0,0,0)\)</span> dann in die Bildmitte. Dazu benötigen wir die kombinierte
Matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{pmatrix}
\frac{W}{2} &amp; 0 &amp; 0 &amp; \frac{W}{2}\\
0 &amp; \frac{H}{2} &amp; 0 &amp; \frac{H}{2}\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}\end{split}\]</div>
<section id="aufgabe-implementieren-sie-die-funktionen-ndc-to-image">
<h3><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>ndc_to_image</em><a class="headerlink" href="#aufgabe-implementieren-sie-die-funktionen-ndc-to-image" title="Link to this heading"></a></h3>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">ndc_to_image</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">translate_3d</span><span class="p">(</span><span class="n">W</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">H</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">@</span> <span class="n">scale</span><span class="p">(</span><span class="n">W</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">H</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="die-kameramatrix">
<h2>Die Kameramatrix<a class="headerlink" href="#die-kameramatrix" title="Link to this heading"></a></h2>
<p>Die Kameramatrix beschreibt, wie die Weltkoordiaten in das Kamerakoordinatensystem transformiert werden.
Auch wenn die Kameramatrix in dieser Transformationsrichtung angegebenen werden muß kann es einfach er sein sich
zunächst vorzustellen was mit der Kamera in der Welt passieren soll (welche Transformationen auf die Kamera angewendet werden sollen) und
diese dann umzukehren. Dabei gilt ganz allgemein für zwei Transformationen</p>
<div class="math notranslate nohighlight">
\[(A\cdot B)^{-1} = B^{-1} \cdot A^{-1}\]</div>
<p>d.h. beim invertieren vertauschen die Matrizen ihre Reihenfolge. Für dieses Tutorial möchten wir die Kamera nun um
164 Einheiten nach hinten (entlang der negativen Z-Achse) und um 16 Einheiten nach unten schieben. Anschließend möchten wir
zuerst 30° um die X-Achse drehen und anschließend -35° um die Y-Achse drehen. Um die Kamera in die Welt zu transformieren möchten
wir also die folgenden Transformationen durchzuführen</p>
<div class="math notranslate nohighlight">
\[\mbox{cam_to_world} = R_y(-35°) \cdot R_x(30°) \cdot T(0, -16, -164)\]</div>
<p>Wie erwähnt müssen wir für die Engine jedoch die Umkehrung davon anwenden, also</p>
<div class="math notranslate nohighlight">
\[\mbox{world_to_cam} = \mbox{cam_to_world}^{-1}\]</div>
<p>Dazu vertauschen wir die Reihenfolge der Transformationen und invertieren diese jeweils einzeln. Wir finden</p>
<div class="math notranslate nohighlight">
\[\mbox{world_to_cam} = T(0, 16, 164) \cdot R_x(-30°) \cdot R_y(35°)\]</div>
<section id="aufgabe-implementieren-sie-die-funktionen-world-to-camera">
<h3><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>world_to_camera</em><a class="headerlink" href="#aufgabe-implementieren-sie-die-funktionen-world-to-camera" title="Link to this heading"></a></h3>
<p>Implementieren Sie nun die Funktion <em>world_to_camera</em></p>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">world_to_camera</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">translate_3d</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">16.0</span><span class="p">,</span> <span class="mf">164.0</span><span class="p">)</span> <span class="o">@</span> <span class="n">rotateX</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="o">-</span><span class="mf">30.0</span><span class="p">))</span> <span class="o">@</span> <span class="n">rotateY</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">35.0</span><span class="p">))</span>
</pre></div>
</div>
</div>
</section>
<section id="von-lokalen-koordinaten-nach-weltkoordinaten">
<h3>Von lokalen Koordinaten nach Weltkoordinaten<a class="headerlink" href="#von-lokalen-koordinaten-nach-weltkoordinaten" title="Link to this heading"></a></h3>
<p>Um die lokalen Koordinaten unseres Objektes (z.B. eines Würfels) in globale Weltkoordiaten umzurechnen verwenden
wir eine Kombination von Transformation in ganz bestimmter Reihenfolge.</p>
<ul class="simple">
<li><p>Zuerst wird das Objekt ggf. skaliert. Dazu kann <code class="xref py py-func docutils literal notranslate"><span class="pre">homogen.scale()</span></code> verwendet werden.</p></li>
<li><p>Anschließend wird das Objekt rotiert. Dabei wird nach Konvention zunächst um die X-Achse, dann um die Y-Achse und zuletzt um die Z-Achse gedreht. Dazu kann die Methode <code class="xref py py-func docutils literal notranslate"><span class="pre">homogen.rotateXYZ()</span></code> verwendet werden.</p></li>
<li><p>Nun wird das Objekt in seinen neuen Ursprung verschoben, dazu kann <code class="xref py py-func docutils literal notranslate"><span class="pre">homogen.translate_3d()</span></code> verwendet werden.</p></li>
<li><p>Zu guter letzt wird das Objekt noch einmal rotiert. Da es nun nicht mehr im Ursprung liegt rotiert es um eben diesen. Es umkeist (orbitet) somit den Ursprung des Weltkoordinatensystems.
Dazu kann wieder :py:func`homogen.rotateXYZ` verwendet werden.</p></li>
</ul>
</section>
<section id="aufgabe-implementieren-sie-die-funktionen-local-to-world">
<h3><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>local_to_world</em><a class="headerlink" href="#aufgabe-implementieren-sie-die-funktionen-local-to-world" title="Link to this heading"></a></h3>
<p>Implementieren Sie nun die Funktion <em>local_to_world</em></p>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">local_to_world</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">rotateXYZ</span><span class="p">(</span><span class="n">objectOrbit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">objectOrbit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">objectOrbit</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">@</span>\
           <span class="n">translate_3d</span><span class="p">(</span><span class="n">objectTranslate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">objectTranslate</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">objectTranslate</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">@</span>\
           <span class="n">rotateXYZ</span><span class="p">(</span><span class="n">objectRotate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">objectRotate</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">objectRotate</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">@</span>\
           <span class="n">scale</span><span class="p">(</span><span class="n">objectScale</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">objectScale</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">objectScale</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</div>
</section>
<section id="von-weltkoordiaten-nach-bildkoordinaten">
<h3>Von Weltkoordiaten nach Bildkoordinaten<a class="headerlink" href="#von-weltkoordiaten-nach-bildkoordinaten" title="Link to this heading"></a></h3>
<p>Solange die Kamera, die Projektion und das Mapping in Bildkoordinaten statisch ist (sich also nicht verändert)
kann die Transformation von Welt- nach Bildkoordinaten einmalig im vorraus berechnet werden.</p>
</section>
<section id="id1">
<h3><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>world_to_camera</em><a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p>Implementieren Sie nun die Funktion <em>world_to_image</em></p>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">world_to_image</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ndc_to_image</span><span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span> <span class="o">@</span> <span class="n">projection</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">@</span> <span class="n">world_to_camera</span><span class="p">()</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="die-datenstruktur-fur-geometriedaten">
<h2>Die Datenstruktur für Geometriedaten<a class="headerlink" href="#die-datenstruktur-fur-geometriedaten" title="Link to this heading"></a></h2>
<p>Um Objekte in 3D zu repräsentieren (z.B. den Würfel) verwenden wir eine spezielle Datenstruktur.
Insbesondere verwenden wir einen s.g. <strong>Vertex</strong>-Buffer welcher die Koordinaten alle Eckpunkte speichert sowie einen
<strong>Index</strong>-Buffer, in dem gespeichert wird welche Ecken miteinander verbunden sind.</p>
<a class="reference internal image-reference" href="../_images/datastructure.png"><img alt="Datenstruktur für Geometriedaten" class="align-center" src="../_images/datastructure.png" style="width: 1024px;" />
</a>
<p>Dabei werden die Vertexkoordinaten stets in lokalen Koordinaten gespeichert und über geeignete Transformationsmatrizen später
ins Weltkoordiatensystem überführt. Im konkreten Falle des Würfels sieht der Vertex-Buffer so aus</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">vertices</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
            <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]]</span>
</pre></div>
</div>
<p>während der Index-Buffer so aussieht</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">2</span> <span class="mi">0</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">6</span> <span class="mi">4</span> <span class="mi">0</span> <span class="mi">4</span> <span class="mi">1</span> <span class="mi">5</span> <span class="mi">2</span> <span class="mi">6</span> <span class="mi">3</span> <span class="mi">7</span><span class="p">]</span>
</pre></div>
</div>
<p>Der Vertexbuffer ist also eine <span class="math notranslate nohighlight">\(4\times n\)</span>-Matrix, wobei <span class="math notranslate nohighlight">\(n\)</span> die Anzahl der Vertices angibt. Die Vertices sind
dabei spaltenweise in homogenen Koordinaten gespeichert. Um alle Vertices über eine Transformationsmatrix in ein anderes Koordinatensystem zu überführen
genügt es demnach den Vertexbuffer <strong>von links</strong> mit der entsprechenden Matrix zu multiplizieren.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">vertices</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
            <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">local_to_image</span> <span class="o">@</span> <span class="n">vertices</span><span class="p">)</span>

<span class="p">[[</span><span class="mf">989.64</span> <span class="mf">745.36</span> <span class="mf">933.</span>   <span class="mf">688.72</span> <span class="mf">912.78</span> <span class="mf">668.5</span>  <span class="mf">856.14</span> <span class="mf">611.86</span><span class="p">]</span>
 <span class="p">[</span><span class="mf">881.22</span> <span class="mf">825.4</span>  <span class="mf">625.49</span> <span class="mf">569.67</span> <span class="mf">897.81</span> <span class="mf">841.99</span> <span class="mf">642.08</span> <span class="mf">586.27</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mf">1.72</span>   <span class="mf">1.49</span>   <span class="mf">1.58</span>   <span class="mf">1.34</span>   <span class="mf">1.89</span>   <span class="mf">1.65</span>   <span class="mf">1.74</span>   <span class="mf">1.51</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mf">1.72</span>   <span class="mf">1.49</span>   <span class="mf">1.58</span>   <span class="mf">1.34</span>   <span class="mf">1.89</span>   <span class="mf">1.65</span>   <span class="mf">1.74</span>   <span class="mf">1.51</span><span class="p">]]</span>
</pre></div>
</div>
<p>In diesem Beispiel sein</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">local_to_image</span> <span class="o">=</span> <span class="n">ndc_to_image</span> <span class="o">@</span> <span class="n">camera_to_ndc</span> <span class="o">@</span> <span class="n">world_to_camera</span> <span class="o">@</span> <span class="n">local_to_world</span>
</pre></div>
</div>
<p>die Projektionmatrix welche von lokalen Koordinaten in Bildkoordinaten abbildet. Da die Koordinaten immer noch homogen sind
muß noch durch die <span class="math notranslate nohighlight">\(w\)</span>-Komponente dividiert werden um euklische Bildkoordinaten zu erhalten.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">vertices</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
            <span class="p">[</span><span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span> <span class="o">-</span><span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]</span>
            <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span>  <span class="mf">1.</span><span class="p">]]</span>

<span class="n">image_coordinates</span> <span class="o">=</span> <span class="n">local_to_image</span> <span class="o">@</span> <span class="n">vertices</span>
<span class="n">image_coordinates</span> <span class="o">/=</span> <span class="n">image_coordinates</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">image_coordinates</span><span class="p">)</span>

<span class="p">[[</span><span class="mf">575.09</span> <span class="mf">501.12</span> <span class="mf">591.44</span> <span class="mf">512.42</span> <span class="mf">483.91</span> <span class="mf">404.46</span> <span class="mf">491.21</span> <span class="mf">405.35</span><span class="p">]</span>
 <span class="p">[</span><span class="mf">512.08</span> <span class="mf">554.93</span> <span class="mf">396.5</span>  <span class="mf">423.84</span> <span class="mf">475.97</span> <span class="mf">509.43</span> <span class="mf">368.39</span> <span class="mf">388.39</span><span class="p">]</span>
 <span class="p">[</span>  <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>  <span class="p">]</span>
 <span class="p">[</span>  <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>     <span class="mf">1.</span>  <span class="p">]]</span>
</pre></div>
</div>
<section id="aufgabe-implementieren-sie-die-funktionen-project-vertexbuffer">
<h3><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>project_vertexbuffer</em><a class="headerlink" href="#aufgabe-implementieren-sie-die-funktionen-project-vertexbuffer" title="Link to this heading"></a></h3>
<p>Implementieren Sie nun die Funktion <em>project_vertexbuffer</em></p>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">project_vertexbuffer</span><span class="p">(</span><span class="n">local_to_image</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
    <span class="c1"># First, project all vertices using the given transformation</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">local_to_image</span> <span class="o">@</span> <span class="n">vertices</span>

    <span class="c1"># Now divide by w to convert to euclidean coordinates</span>
    <span class="n">vertices</span> <span class="o">/=</span> <span class="n">vertices</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span>

    <span class="k">return</span> <span class="n">vertices</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="die-vertices-zeichnen">
<h2>Die Vertices zeichnen<a class="headerlink" href="#die-vertices-zeichnen" title="Link to this heading"></a></h2>
<p>Um die Vertices nun zeichnen zu können müssen wir im Grunde nur noch den Indexbuffer abarbeiten.
Immer zwei aufeinanderfolgende Indices entsprechen dabei einer zu zeichnenden Linie. Wir können diese Logik nun implementieren.</p>
<section id="aufgabe-implementieren-sie-die-funktionen-draw">
<h3><strong>Aufgabe</strong>: Implementieren Sie die Funktionen <em>draw</em><a class="headerlink" href="#aufgabe-implementieren-sie-die-funktionen-draw" title="Link to this heading"></a></h3>
<ul>
<li><p>Als erstes entpacken Sie das Tupel <cite>mesh</cite> und extrahieren Sie so den Vertex- und den Indexbuffer.</p></li>
<li><p>Projezieren Sie die Vertices dann mit der <code class="xref py py-func docutils literal notranslate"><span class="pre">project_vertexbuffer()</span></code> Methode in Bildkoordinaten.</p></li>
<li><p>Iterieren Sie dann über den Index-Buffer und laden Sie die indices der zu zeichnenden Vertices, etwa so</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">lineIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">indexA</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">lineIndex</span><span class="p">]</span>
    <span class="n">indexB</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">lineIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><p>Laden Sie anschließend die jeweiligen Vertices aus dem projezierten Vertexbuffer, runden Sie die X- und Y-Koordinaten
und verwenden Sie <a class="reference external" href="https://www.geeksforgeeks.org/python-opencv-cv2-line-method/">cv2.line</a> um eine Linie in der
angegebenen Farbe zu zeichnen.</p></li>
</ul>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">draw</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">local_to_image</span><span class="p">,</span> <span class="n">canvas</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
    <span class="c1"># Unpack mesh</span>
    <span class="n">vertices</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">mesh</span>

    <span class="c1"># Project vertices</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">project_vertexbuffer</span><span class="p">(</span><span class="n">local_to_image</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>

    <span class="c1"># Go through list of indices</span>
    <span class="k">for</span> <span class="n">lineIndex</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">):</span>
        <span class="c1"># Indirect access</span>
        <span class="n">indexA</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">lineIndex</span><span class="p">]</span>
        <span class="n">indexB</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">lineIndex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="n">indexA</span><span class="p">]</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[:,</span> <span class="n">indexB</span><span class="p">]</span>

        <span class="n">cv2</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">canvas</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">col</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="musterlosung">
<h2>Musterlösung<a class="headerlink" href="#musterlosung" title="Link to this heading"></a></h2>
<p><a class="reference internal" href="source.html"><span class="doc">Homogene Koordinaten - Musterlösung</span></a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../HOG/index.html" class="btn btn-neutral float-left" title="Histogram of Oriented Gradients" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Zurück</a>
        <a href="../mahalanobis/index.html" class="btn btn-neutral float-right" title="Mahalanobis-Distanz und Kovarianzellipsen" accesskey="n" rel="next">Weiter <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Prof. Dr. Dennis Müller.</p>
  </div>

  Erstellt mit <a href="https://www.sphinx-doc.org/">Sphinx</a> mit einem
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    bereitgestellt von <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>