

<!DOCTYPE html>
<html class="writer-html5" lang="de" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Histogram of Oriented Gradients &mdash; Machine Perception and Tracking - Praktikum  Dokumentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />

  
    <link rel="canonical" href="https://dmu1981.github.io/MPTPraktikum/HOG/index.html" />
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=245627df"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
      <script src="../_static/translations.js?v=79cc9f76"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Stichwortverzeichnis" href="../genindex.html" />
    <link rel="search" title="Suche" href="../search.html" />
    <link rel="next" title="Homogene Koordinaten" href="../homogen/index.html" />
    <link rel="prev" title="AdaBoost - Praktikumsaufgabe" href="../AdaBoost/index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Machine Perception and Tracking - Praktikum
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Dokumentation durchsuchen" aria-label="Dokumentation durchsuchen" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Aufgaben:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../webcam/index.html">Die Webcam öffnen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kanten/index.html">Kantendetektion mit Sobel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../harris/index.html">Der Harris Eckendetektor</a></li>
<li class="toctree-l1"><a class="reference internal" href="../YOLO/index.html">Objekterkennung mit YOLO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../AdaBoost/index.html">AdaBoost</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Histogram of Oriented Gradients</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#hog-uberblick">HoG - Überblick</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hog-from-scratch-die-webcam-offnen">HoG from Scratch - Die Webcam öffnen</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hog-from-scratch-die-gradientenrichtungen">HoG from Scratch - Die Gradientenrichtungen</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hog-from-scratch-gradienten-und-gradientestarke">HoG from Scratch - Gradienten und Gradientestärke</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hog-from-scratch-gradientenrichtung">HoG from Scratch - Gradientenrichtung</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hog-from-scratch-gradientenrichtungen-anzeigen">HoG from Scratch - Gradientenrichtungen anzeigen</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hog-from-scratch-der-feature-vektor">HoG from Scratch - Der Feature-Vektor</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hog-from-scratch-visualisierung-einer-hog-zelle">HoG from Scratch - Visualisierung einer HoG-Zelle</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hog-from-scratch-berechnen-der-features-uber-das-ganze-bild">HoG from Scratch - Berechnen der Features über das ganze Bild</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hog-from-scratch-musterlosung">HoG from Scratch - Musterlösung</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../homogen/index.html">Rechnen mit homogene Koordinaten</a></li>
<li class="toctree-l1"><a class="reference internal" href="../mahalanobis/index.html">Mahalanobisdistanz</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nonlinearmapping/index.html">Nichtlineare Abbildung normalverteilter Zufallsvariablen</a></li>
<li class="toctree-l1"><a class="reference internal" href="../multivariate/index.html">Minimum Varianz Fusion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../forwardalgorithm/index.html">Der Vorwärts-Algorithmus</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kalman/index.html">Das Kalman-Filter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../kalman/index.html#bewegungs-und-messmodell">Bewegungs- und Messmodell</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Machine Perception and Tracking - Praktikum</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Histogram of Oriented Gradients</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/HOG/index.rst.txt" rel="nofollow"> Quelltext anzeigen</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="histogram-of-oriented-gradients">
<h1>Histogram of Oriented Gradients<a class="headerlink" href="#histogram-of-oriented-gradients" title="Link to this heading"></a></h1>
<p>Bei den s.g. HoG (Histogram of Oriented Gradients) Featuren handelt es sich um eine frühe
Technik aus einem Bild geeigente Informationen (Features) abzuleiten
um damit komplexe Objekte klassifizeiren zu können. Konkret wurden HOG-Features
zuerst von N. Dalal und B. Triggs in <a class="reference external" href="https://ieeexplore.ieee.org/document/1467360">Histograms of oriented gradients for human detection, IEEE 2005</a>
vorgeschlagen.</p>
<section id="hog-uberblick">
<h2>HoG - Überblick<a class="headerlink" href="#hog-uberblick" title="Link to this heading"></a></h2>
<p>Zunächst werden für das Bild mit dem Sobel-Operator die Gradienten in X und Y-Richtung bestimmt.
Es wird eine feste Anzahl an möglichen Gradientenrichtungen (z.B. 8) festgelegt und zu jedem Pixel wird
festgelegt in welche dieser möglichen Richtungen der Gradient an dieser Stelle zeigt (die Gradientenrichtungen werden quantisiert).</p>
<p>Dann wird das Bild in kleinere Blöcke unterteilt (z.B. 8x8 Pixel). Zu jedem Block wird nun für alle
möglichen Gradientenrichtungen gezählt wieviele der Pixel in diese Richtung „zeigen“. Es wird also für diesen Block
ein Histogram der vorkommenden Gradientenrichtungen erstellt. Um weniger sensibel gegenüber Bildrauschen zu sein werden
die Gradientenrichtungen mit ihrer jeweiligen Gradientenstärke gewichtet.</p>
</section>
<section id="hog-from-scratch-die-webcam-offnen">
<h2>HoG from Scratch - Die Webcam öffnen<a class="headerlink" href="#hog-from-scratch-die-webcam-offnen" title="Link to this heading"></a></h2>
<p>Wir beginnen wieder mit unserem Standard Loop und öffnen die Webcam. Wandeln Sie das Bild direkt in ein Graustufenbild (0 bis 255) und
<a class="reference external" href="https://numpy.org/doc/stable/user/basics.types.html">konvertieren</a> Sie den Datentyp in <cite>np.float32</cite> (0.0 bis 1.0).</p>
<p>und rufen sie die noch zu
implementierende Methode <cite>process_hog</cite> mit diesem Grauwertbild auf. Hier nocheinmal die Auflistung der Methoden die dir dabei helfen können:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://docs.opencv.org/4.x/d8/dfe/classcv_1_1VideoCapture.html">cv2.VideoCapture</a> – öffnet einen Video-Stream oder eine Kamera.</p></li>
<li><p><a class="reference external" href="https://docs.opencv.org/4.x/d8/dfe/classcv_1_1VideoCapture.html#a473055e77dd7faa4d26d686226b292c1">cv2.VideoCapture.read</a> – liest einen Frame aus dem Stream.</p></li>
<li><p><a class="reference external" href="https://docs.opencv.org/4.x/d8/dfe/classcv_1_1VideoCapture.html#a9d2ca36789e7fcfe7a7be3b328038585">cv2.VideoCapture.isOpened</a> – prüft, ob die Kamera geöffnet werden konnte.</p></li>
<li><p><a class="reference external" href="https://www.geeksforgeeks.org/python-opencv-cv2-cvtcolor-method/">cv2.cvtColor</a> – konvertiert Farbräume (z. B. in Graustufen).</p></li>
<li><p><a class="reference external" href="https://www.geeksforgeeks.org/python-opencv-waitkey-function/">cv2.waitKey</a> – wartet auf Tasteneingabe.</p></li>
</ul>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">process_hog</span><span class="p">(</span><span class="n">gray</span><span class="p">):</span>
  <span class="k">pass</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
  <span class="n">cap</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">VideoCapture</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">cap</span><span class="o">.</span><span class="n">isOpened</span><span class="p">():</span>
      <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cannot open camera&quot;</span><span class="p">)</span>
      <span class="n">exit</span><span class="p">()</span>

  <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
      <span class="c1"># Capture frame-by-frame</span>
      <span class="n">ret</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">cap</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

      <span class="c1"># if frame is read correctly ret is True</span>
      <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
          <span class="n">exit</span><span class="p">()</span>

      <span class="c1"># Convert image to gray scale</span>
      <span class="n">gray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">)</span>

      <span class="n">process_hog</span><span class="p">(</span><span class="n">gray</span><span class="p">)</span>

      <span class="c1"># Display the resulting frame</span>
      <span class="k">if</span> <span class="n">cv2</span><span class="o">.</span><span class="n">waitKey</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">ord</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">):</span>
          <span class="k">break</span>
</pre></div>
</div>
</div>
</section>
<section id="hog-from-scratch-die-gradientenrichtungen">
<h2>HoG from Scratch - Die Gradientenrichtungen<a class="headerlink" href="#hog-from-scratch-die-gradientenrichtungen" title="Link to this heading"></a></h2>
<p>Im ersten Schritt bestimmen wir zunächst die Richtungen der quantisierten Gradientenrichtungen.
Dazu teilen wir das Intervall von 0 bis <span class="math notranslate nohighlight">\(2\pi\)</span> in gleichmäßige Schritten ein.</p>
<p>Verwenden Sie <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linspace.html">numpy.linspace</a> und schließen Sie den letzten Datenpunkt
aus weil 0° Grad und 360° natürlich der selben Richtung entsprechen. Für z.B. 8 Gradientenrichtungen sollten Sie die folgenden Winkel finden</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">winkel</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span>    <span class="mf">0.785</span> <span class="mf">1.571</span> <span class="mf">2.356</span> <span class="mf">3.142</span> <span class="mf">3.927</span> <span class="mf">4.712</span> <span class="mf">5.498</span><span class="p">]</span>
</pre></div>
</div>
</div></blockquote>
<p>Zu einem konkreten Winkel <span class="math notranslate nohighlight">\(\alpha\)</span> können wir die dazugehörige Gradientenrichtung <span class="math notranslate nohighlight">\(\vec v\)</span> berechnen</p>
<div class="math notranslate nohighlight">
\[\begin{split}\vec v(\alpha) = \begin{pmatrix}\cos(\alpha)\\ \sin(\alpha)\end{pmatrix}\end{split}\]</div>
<p>Berechnen Sie nun für jeden der Winkel die dazugehörige Winkelrichtung und speichern Sie alle Winkel in einem <span class="math notranslate nohighlight">\(2xN\)</span> array. Für z.B. 8 Gradientenrichtungen sollte
ihre Array dann so aussehen</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">directions</span> <span class="o">=</span> <span class="p">[[</span> <span class="mf">1.</span>     <span class="mf">0.707</span>  <span class="mf">0.</span>    <span class="o">-</span><span class="mf">0.707</span> <span class="o">-</span><span class="mf">1.</span>    <span class="o">-</span><span class="mf">0.707</span> <span class="o">-</span><span class="mf">0.</span>     <span class="mf">0.707</span><span class="p">]</span>
              <span class="p">[</span> <span class="mf">0.</span>     <span class="mf">0.707</span>  <span class="mf">1.</span>     <span class="mf">0.707</span>  <span class="mf">0.</span>    <span class="o">-</span><span class="mf">0.707</span> <span class="o">-</span><span class="mf">1.</span>    <span class="o">-</span><span class="mf">0.707</span><span class="p">]]</span>
</pre></div>
</div>
</div></blockquote>
<p>Schreiben Sie eine Funktion <cite>calculate_gradient_directions</cite> welche zu einer Anzahl an Richtungen dieses dazugehörige Array zurückgibt.</p>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">calculate_gradient_directions</span><span class="p">(</span><span class="n">totalDirections</span> <span class="o">=</span> <span class="mi">12</span><span class="p">):</span>
  <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">totalDirections</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="n">hogDirections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">totalDirections</span><span class="p">))</span>

  <span class="n">hogDirections</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
  <span class="n">hogDirections</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">hogDirections</span>
</pre></div>
</div>
</div>
</section>
<section id="hog-from-scratch-gradienten-und-gradientestarke">
<h2>HoG from Scratch - Gradienten und Gradientestärke<a class="headerlink" href="#hog-from-scratch-gradienten-und-gradientestarke" title="Link to this heading"></a></h2>
<p>Nun implementieren wir die <cite>process_hog</cite> Methode. Berechnen Sie zunächst wieder für das Grauwertbild mit <a class="reference external" href="https://docs.opencv.org/3.4/d4/d86/group__imgproc__filter.html#gacea54f142e81b6758cb6f375ce782c8d">cv2.Sobel</a>
die Gradienten in X und Y-Richtung. Verwenden Sie <cite>ksize=5</cite> und berechnen Sie die Gradientenstärke als</p>
<div class="math notranslate nohighlight">
\[\nabla I = \sqrt{I_x^2 + I_y^2}\]</div>
<p>Speichern Sie das Gradientenbild in X-Richtung als <cite>gx</cite>, das Gradientenbild in Y-Richtung als <cite>gy</cite> sowie
die Gradientstärke als <cite>mag</cite>.</p>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">process_hog</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">totalDirections</span> <span class="o">=</span> <span class="mi">12</span><span class="p">):</span>
  <span class="n">gx</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Sobel</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CV_32F</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ksize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">gy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Sobel</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CV_32F</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ksize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="hog-from-scratch-gradientenrichtung">
<h2>HoG from Scratch - Gradientenrichtung<a class="headerlink" href="#hog-from-scratch-gradientenrichtung" title="Link to this heading"></a></h2>
<p>Zur Bestimmung der Gradientenrichtung bestimmen wir das Skalarprodukt</p>
<div class="math notranslate nohighlight">
\[\left(I_x,  I_y\right) \cdot \vec v(\alpha)\]</div>
<p>für alle möglichen Gradientenrichtungen und ordnen den Pixel derjenigen Richtung zu, wo
dieses Skalarprodukt maximal wird. Mathematisch berechnen wir also</p>
<div class="math notranslate nohighlight">
\[\arg\max_j \left(I_x,  I_y\right) \cdot \vec v(\alpha_j) =
\arg\max_j \left(\cos(\alpha_j) I_x + \sin(\alpha_j) I_y\right)\]</div>
<p>für jeden Pixel.</p>
<p>Um diese Berechnung zu vereinfachen, <em>flatten</em> Sie zunächst die Gradientenbilder <cite>gx</cite> und <cite>gy</cite> (<a class="reference external" href="https://numpy.org/doc/2.1/reference/generated/numpy.ndarray.flatten.html">numpy.flatten</a>).
Erzeugen Sie dann gleichgroße neue Arrays <cite>winningBin</cite> und <cite>bestDot</cite> gefüllt mit nullen (<a class="reference external" href="https://numpy.org/doc/2.2/reference/generated/numpy.zeros_like.html">np.zeros_like</a>)</p>
<p>Iterieren Sie über alle Gradientenrichtungen (rufen Sie Ihre Funktion <cite>calculate_gradient_directions</cite> auf um diese Richtungen zu bekommen) und berechnen Sie
das Skalarprodukt (siehe oben). Bestimmen Sie diejenigen Einträge, bei denen das neue Skalarprodukt größer ist als das bisherige (vgl. mit <cite>bestDot</cite>)
und überschreiben Sie für diese Einträge sowohl <cite>bestDot</cite> (mit dem neuen, größeren Skalarprodukt) als auch <cite>winningBin</cite> mit dem Index des aktuell geprüften Bins.</p>
<p>Am Ende erhalten Sie so zu jedem Pixel ihres Originalbildes denjenigen Index (Bin) der Gradientenrichtung, die am ehesten den tatsächlichen
Gradienten des Pixels repräsentiert (in <cite>winningBin</cite>) sowie dessen Gradientenstärke (in <cite>mag</cite>).</p>
<p>Damit <cite>winningBin</cite> wieder als Bild interpretiert werden kann <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.reshape.html">reshapen</a> sie das Bild wieder auf die Größen des originalen Grauwertbildes.</p>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">process_hog</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">totalDirections</span> <span class="o">=</span> <span class="mi">12</span><span class="p">):</span>
  <span class="n">gx</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Sobel</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CV_32F</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ksize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">gy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Sobel</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CV_32F</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ksize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

  <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">gx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">gy</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
  <span class="n">winningBin</span><span class="p">,</span> <span class="n">bestDot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gx</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">totalDirections</span><span class="p">):</span>
    <span class="n">dot</span> <span class="o">=</span> <span class="n">gx</span> <span class="o">*</span> <span class="n">hogDirections</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">direction</span><span class="p">]</span> <span class="o">+</span> <span class="n">gy</span> <span class="o">*</span> <span class="n">hogDirections</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">direction</span><span class="p">]</span>

    <span class="n">greaterIndices</span> <span class="o">=</span> <span class="n">dot</span> <span class="o">&gt;</span> <span class="n">bestDot</span>
    <span class="n">winningBin</span><span class="p">[</span><span class="n">greaterIndices</span><span class="p">]</span> <span class="o">=</span> <span class="n">direction</span>
    <span class="n">bestDot</span><span class="p">[</span><span class="n">greaterIndices</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">[</span><span class="n">greaterIndices</span><span class="p">]</span>

  <span class="n">winningBin</span> <span class="o">=</span> <span class="n">winningBin</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gray</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="hog-from-scratch-gradientenrichtungen-anzeigen">
<h2>HoG from Scratch - Gradientenrichtungen anzeigen<a class="headerlink" href="#hog-from-scratch-gradientenrichtungen-anzeigen" title="Link to this heading"></a></h2>
<p>Es macht Sinn diese Gradientenrichtungen konkret anzuzeigen um ein
Gefühl für die so kodierte Information zu bekommen. Wandeln Sie dazu das <cite>winningBin</cite> Bild zunächst
in ein Grauwertbild zurück indem Sie den Bereich der möglichen Bins <span class="math notranslate nohighlight">\([0,\dots,N-1]\)</span> linear auf den Bereich <span class="math notranslate nohighlight">\([0,\dots,255]\)</span>
abbilden. Wandeln Sie auch den Datentypen zurück in einen <cite>np.uint8</cite>. Verwenden Sie dann
<a class="reference external" href="https://docs.opencv.org/3.4/d3/d50/group__imgproc__colormap.html">cv2.applyColoMap</a> um das Bild geeignet einzufärben (z.B. mit der <cite>cv2.COLORMAP_JET</cite> Farbskala) und zeigen Sie es mit
<a class="reference external" href="https://www.geeksforgeeks.org/python-opencv-cv2-imshow-method/">cv2.imshow</a> an. Es kann für die Anzeige Sinn machen zu schwache Gradienten
zu unterdrücken. Setzen Sie daher in ihrem Farbbild alle Pixel auf <span class="math notranslate nohighlight">\((0,0,0)\)</span>, für welche die Gradientestärke geringen als 1.5 ist.</p>
<p>Ihr Bild sollte dann in etwa so aussehen (bei 12 Histogrambins):</p>
<a class="reference internal image-reference" href="../_images/gradientdirections.png"><img alt="Gradientenrichtungsbild" class="align-center" src="../_images/gradientdirections.png" style="width: 400px;" />
</a>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">process_hog</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">totalDirections</span> <span class="o">=</span> <span class="mi">12</span><span class="p">):</span>
  <span class="n">gx</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Sobel</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CV_32F</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ksize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">gy</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">Sobel</span><span class="p">(</span><span class="n">gray</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">CV_32F</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ksize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">gx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">gy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

  <span class="n">gx</span><span class="p">,</span> <span class="n">gy</span> <span class="o">=</span> <span class="n">gx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">gy</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
  <span class="n">winningBin</span><span class="p">,</span> <span class="n">bestDot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gx</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">direction</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">totalDirections</span><span class="p">):</span>
    <span class="n">dot</span> <span class="o">=</span> <span class="n">gx</span> <span class="o">*</span> <span class="n">hogDirections</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">direction</span><span class="p">]</span> <span class="o">+</span> <span class="n">gy</span> <span class="o">*</span> <span class="n">hogDirections</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">direction</span><span class="p">]</span>

    <span class="n">greaterIndices</span> <span class="o">=</span> <span class="n">dot</span> <span class="o">&gt;</span> <span class="n">bestDot</span>
    <span class="n">winningBin</span><span class="p">[</span><span class="n">greaterIndices</span><span class="p">]</span> <span class="o">=</span> <span class="n">direction</span>
    <span class="n">bestDot</span><span class="p">[</span><span class="n">greaterIndices</span><span class="p">]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">[</span><span class="n">greaterIndices</span><span class="p">]</span>

  <span class="n">winningBin</span> <span class="o">=</span> <span class="n">winningBin</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">gray</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

  <span class="n">binGray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">winningBin</span> <span class="o">/</span> <span class="p">(</span><span class="n">totalDirections</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
  <span class="n">binColor</span><span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">applyColorMap</span><span class="p">(</span><span class="n">binGray</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLORMAP_JET</span><span class="p">)</span>
  <span class="n">binColor</span><span class="p">[</span><span class="n">mag</span> <span class="o">&lt;</span> <span class="mf">1.5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

  <span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s2">&quot;Gradient Direction&quot;</span><span class="p">,</span> <span class="n">binColor</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="hog-from-scratch-der-feature-vektor">
<h2>HoG from Scratch - Der Feature-Vektor<a class="headerlink" href="#hog-from-scratch-der-feature-vektor" title="Link to this heading"></a></h2>
<p>Implementieren Sie nun eine Methode <cite>hog_cell</cite>. Diese soll das Magnituden-Bild <cite>mag</cite>, die dominanten Gradientenrichtungen <cite>winningBin</cite>
sowie die Anzahl der Gradientenrichtungen erhalten. Eine geeignete Signatur dieser Methode könnte so aussehen:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">hog_cell</span><span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">winningBin</span><span class="p">,</span> <span class="n">totalDirections</span><span class="p">):</span>
</pre></div>
</div>
<p>Das Ziel ist es hier für die übergebenen Bilder (später: Bildausschnitte) das Histogram der
Gradientenrichtungen zu berechnen und als normierten Feature-Vektor zurückzugeben. Wenn wir also <span class="math notranslate nohighlight">\(N\)</span> Gradientenrichtungen haben geben wir einen
<span class="math notranslate nohighlight">\(N\)</span>-dimensionalen Featurevektor zurück, welcher für jede prinzipielle Richtung der Summe der jeweiligen Gradientenstärken enthält. Mathematisch berechnen wir also</p>
<div class="math notranslate nohighlight">
\[\textbf{h} = \left(h_0, h_1, \dots, h_n\right)\]</div>
<p>mit</p>
<div class="math notranslate nohighlight">
\[h_j = \sum_{winningBin(x,y) = j} mag(x,y)\]</div>
<p><strong>Achtung</strong>: Im Orignalpaper wird der HoG-Featurevektor über mehrere Zellen normalisiert. Wir weichen hier von dieser Implementierung ab und dividieren
den Vektor einfach nur durch eine Konstante (in diesem Fall: 256).</p>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">hog_cell</span><span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">winningBin</span><span class="p">,</span> <span class="n">totalDirections</span><span class="p">):</span>
  <span class="n">cellVector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">totalDirections</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">totalDirections</span><span class="p">):</span>
    <span class="n">cellVector</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">magnitude</span><span class="p">[</span><span class="n">winningBin</span> <span class="o">==</span> <span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

  <span class="k">return</span> <span class="n">cellVector</span> <span class="o">/</span> <span class="mf">256.0</span>
</pre></div>
</div>
</div>
</section>
<section id="hog-from-scratch-visualisierung-einer-hog-zelle">
<h2>HoG from Scratch - Visualisierung einer HoG-Zelle<a class="headerlink" href="#hog-from-scratch-visualisierung-einer-hog-zelle" title="Link to this heading"></a></h2>
<p>Um eine einzelne HoG-Zelle zu visualisieren zeichnen wir für jede der Gradientenrichtungen einen stilisierten Vektorpfeil. Als Helligkeitsintenstät des
Pfeils verwenden wir die akkumulierte Gradientenstärek. Schreiben Sie eine Methode <cite>visualize_hog_cell</cite> welche den gerade berechneten HoG-Vektor,
das Array mit Gradientenrichtungsvektoren sowie die Größe der zu zeichnenden Zelle (Breite und Höhe) erhält. Eine geeignete Signatur dieser Methode könnte also so aussehen:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">visualize_hog_cell</span><span class="p">(</span><span class="n">cellVector</span><span class="p">,</span> <span class="n">directions</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">)):</span>
</pre></div>
</div>
<p>Diese Methode soll ein entsprechend der angegebenen Zellengröße dimensioniertes Grauwertbild zurückgeben. Erzeugen Sie dieses Bild indem Sie mit <a class="reference external" href="https://numpy.org/devdocs/reference/generated/numpy.zeros.html">np.zeros</a> eine
passend dimensionierte Matrix gefüllt mit nullen erzeugen. Iterieren Sie dann über alle Einträge des <cite>cellVector</cite> und bestimmen Sie die dazugehörige Gradientenrichtung anhand des
ebenfalls übergebenen <cite>directions</cite>-Array. Nutzen Sie <a class="reference external" href="https://www.geeksforgeeks.org/python-opencv-cv2-line-method/">cv2.line</a> um ausgehend von der Mitte des Bildes ein Linie in diese Richtung zu
zeichnen. Skalieren Sie den Richtungsvektor <span class="math notranslate nohighlight">\((dx,dy)\)</span> passend zur (halben) Zellengröße und wählen Sie die akkumulierte Gradientenstärke aus dem <cite>cellVector</cite> als Farbe für die Linie.</p>
<p>Geben Sie schließlich das Bild zurück.</p>
<div class="toggle admonition">
<p class="admonition-title">Lösung anzeigen</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">visualize_hog_cell</span><span class="p">(</span><span class="n">cellVector</span><span class="p">,</span> <span class="n">directions</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">16</span><span class="p">)):</span>
  <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cellVector</span><span class="p">):</span>
    <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">directions</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">],</span> <span class="n">directions</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span>

    <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">W</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">H</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">W</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y0</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">H</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">cv2</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>

  <span class="k">return</span> <span class="n">cell</span>
</pre></div>
</div>
</div>
</section>
<section id="hog-from-scratch-berechnen-der-features-uber-das-ganze-bild">
<h2>HoG from Scratch - Berechnen der Features über das ganze Bild<a class="headerlink" href="#hog-from-scratch-berechnen-der-features-uber-das-ganze-bild" title="Link to this heading"></a></h2>
<p>Wir wollen das Bild nun in Zellen der Größe <span class="math notranslate nohighlight">\((12x12)\)</span> Pixel unterteilen. Für jede dieser Zelle schneiden wir den entsprechenden Abschnitt aus dem <cite>winningBin</cite>- und dem <cite>mag</cite>-Bild aus, rufen die
gerade implementierte <cite>hog_cell</cite>-Methode auf um den Featurevektor zu bestimmen und lassen diesen mit der <cite>visualize_hog_cell</cite>-Methode zeichnen. Die entstehenden Einzelbilder kopieren wir zusammen in
ein großes Bild und zeigen dieses ebenfalls an. Eine entsprechende Implementierung könnte z.B. so aussehen</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cellSize</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">hogImage</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">gray</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cellSize</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">y0</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">gray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cellSize</span><span class="p">):</span>
      <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">cellSize</span>

      <span class="n">cellVector</span> <span class="o">=</span> <span class="n">hog_cell</span><span class="p">(</span><span class="n">mag</span><span class="p">[</span><span class="n">y0</span><span class="p">:</span><span class="n">y1</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">],</span> <span class="n">winningBin</span><span class="p">[</span><span class="n">y0</span><span class="p">:</span><span class="n">y1</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">],</span> <span class="n">totalDirections</span><span class="p">)</span>
      <span class="n">hogImage</span><span class="p">[</span><span class="n">y0</span><span class="p">:</span><span class="n">y1</span><span class="p">,</span> <span class="n">x0</span><span class="p">:</span><span class="n">x1</span><span class="p">]</span> <span class="o">=</span> <span class="n">visualize_hog_cell</span><span class="p">(</span><span class="n">cellVector</span><span class="p">,</span> <span class="n">hogDirections</span><span class="p">,</span> <span class="p">(</span><span class="n">cellSize</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">))</span>


<span class="n">cv2</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="s2">&quot;HOG Vector&quot;</span><span class="p">,</span> <span class="n">hogImage</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="hog-from-scratch-musterlosung">
<h2>HoG from Scratch - Musterlösung<a class="headerlink" href="#hog-from-scratch-musterlosung" title="Link to this heading"></a></h2>
<p><a class="reference internal" href="source.html"><span class="doc">Histogram of Oriented Gradients - Musterlösung</span></a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../AdaBoost/index.html" class="btn btn-neutral float-left" title="AdaBoost - Praktikumsaufgabe" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Zurück</a>
        <a href="../homogen/index.html" class="btn btn-neutral float-right" title="Homogene Koordinaten" accesskey="n" rel="next">Weiter <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Prof. Dr. Dennis Müller.</p>
  </div>

  Erstellt mit <a href="https://www.sphinx-doc.org/">Sphinx</a> mit einem
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    bereitgestellt von <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>